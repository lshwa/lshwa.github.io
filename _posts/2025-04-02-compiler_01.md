---
layout : single
title : Compiler - Lexical Analysis (어휘 분석기)
categories : CS study
tags : Compiler
typora-root-url: ../
toc : true
author_profile: false
sidebar:
  nav : "docs"
---

# Compiler

- 컴파일러(Compiler)란?

A compiler is a program that translates computer code in one language into another language

> 어떤 언어의 코드 전체를 다른 언어로 바꿔주는 것을 자동으로 수행하는 소프트웨어 



- 컴파일러를 배워야하는 이유? 

![img](https://blog.kakaocdn.net/dn/V5jEI/btqyBxSr8pS/YP0ZpYSWDBfryId2nlxncK/img.png)

컴퓨터는 오직 **binary code**만 읽을 수 있다. 하지만, 우리가 코딩하는 프로그램은 **human-friendly**에 치우처져있다.

따라서, 코드를 바이너리 코드로 바꿔주는 과정이 필요하다. 

**Compiler translates a "high-level" source program into a "low-level" target program.**

> Interpreter : 한 줄씩 있는 (line-by-line) 

- 컴파일러와 인터프리터의 차이점

| 구분            | 컴파일러                    | 인터프리터                         |
| --------------- | --------------------------- | ---------------------------------- |
| Workflow        | 전체 코드 번역 후 실행      | 한 줄씩 번역하며 실행              |
| Execution time  | **빠름**                    | 느림                               |
| Debugging       | 전체 코드 분석 후 오류 출력 | **실행 중 오류 발생 시 즉시 출력** |
| output program  | 기계어 파일 생성            | 별도 기계어 파일 없음              |
| Usage of memory | 번역 후 실행이므로 효율적   | 실행할 때마다 번역 필요            |
| Example         | C, C++                      | Python, JavaScript                 |



## Structure of Compilers

다음은 컴파일러의 구조이다. 

![생성된 이미지](https://sdmntprwestus.oaiusercontent.com/files/00000000-a6b0-5230-b590-7e7072f605fe/raw?se=2025-04-02T06%3A39%3A10Z&sp=r&sv=2024-08-04&sr=b&scid=21eb7a3e-7f4b-5ded-8db0-e9db2923e71b&skoid=e825dac8-9fae-4e05-9fdb-3d74e1880d5a&sktid=a48cca56-e6da-484e-a814-9c849652bcb3&skt=2025-04-02T05%3A37%3A46Z&ske=2025-04-03T05%3A37%3A46Z&sks=b&skv=2024-08-04&sig=gkbWnp/YhLGtFMsA2BrBx6vBkLFAr648Vdjni7vvBBI%3D)

- Lexical anlayzer (scanner), Syntax analyzer(parser), Semantic analyzer : Analysis part로 front-end에 속한다.
- Intermediate code generator, Code optimizer, Code generator : Synthesis part로 back-end에 속한다.

> Analysis : 소스프로그램에 입력되는 값을 이해하는 단계
>
> Synthesis : 소스프로그램에 대응하는 타겟프로그램을 제작하는 단계 



이번 포스트는 **'Lexical Analyzer(scanner)'**에 다룬다. 

---

# Lexical Analysis (Scanner) 

---

## 1. 컴파일러 구조 내에서의 Lexical Analyzer

### ▪ 역할:
- 소스 프로그램(Source Program)을 **문자열 스트림**에서 **토큰(Token)** 으로 분리하는 **첫 번째 분석 단계**
- 파서(Parser)에게 토큰을 전달함
- 심볼 테이블(Symbol Table)에 식별자 정보를 저장



---

## 2. 토큰(Token), 패턴(Pattern), 렉심(Lexeme)

### ▪ Token:
- 의미 단위 (예: `<id, a>`, `<assign>`, `<num, 2>`)
- 형식: `<token_name, value>` (value는 생략 가능)

### ▪ Pattern:
- 특정 토큰을 구성하는 문자열 규칙 (정규 표현식으로 표현됨)

### ▪ Lexeme:
- 실제 소스코드에서 패턴에 매칭되는 **문자열**

### ▪ Token 종류 예시:

| 종류        | 설명              | 예시              |
| ----------- | ----------------- | ----------------- |
| Keyword     | 예약어            | `if`, `else`      |
| Identifier  | 사용자 정의 이름  | `a`, `val`        |
| Constant    | 숫자 상수         | `3.14`, `10`      |
| Operator    | 연산자            | `=`, `==`, `*`    |
| Punctuation | 구두점            | `(`, `)`, `,`     |
| Whitespace  | 공백, 탭, 개행 등 | `\t`, `\n`, `' '` |

---

## 3. 정규 언어와 정규 표현식

### ▪ Alphabet(Σ): 문자들의 유한 집합 (예: `{0, 1}`, `{a, b, c, ...}`)

### ▪ String: Alphabet에서 만들어진 유한 길이의 문자 시퀀스

### ▪ Language: 특정 Alphabet으로 만든 문자열들의 집합

### ▪ 정규 표현식 정의:
- ∅: 빈 집합
- ε: 빈 문자열
- a ∈ Σ → a는 단일 문자 표현식
- RE 조합 규칙:
  - `r1 | r2` → r1 또는 r2
  - `r1 r2` → r1 다음에 r2
  - `r*` → r을 0번 이상 반복

### ▪ 예시:
- `0|1`: 0 또는 1
- `(0|1)*`: 0과 1의 임의 반복
- `1*1`: 1로 시작해서 1로 끝나는 문자열 (1, 11, 111…)

---

## 4.  정규 표현식 → Finite Automata

### ▪ FA(Finite Automaton): 정규 언어를 인식하는 이론적 모델

### ▪ DFA(결정적 FA):
- 입력과 상태에 따라 전이가 **정해짐**
- ε-transition 없음

### ▪ NFA(비결정적 FA):
- 하나의 입력에 대해 **여러 전이 가능**
- ε-transition 허용

### ▪ DFA와 NFA는 **동등한 표현력**을 가짐

---

## 5. NFA와 DFA 구현 (스캐너 생성 절차)

### ▪ 전체 흐름:

Token 패턴 → 정규 표현식(RE)

→ NFA (Thompson’s Construction)

→ DFA (Subset Construction)

→ Transition Table → Scanner 코드

### ▪ Thompson's Construction:
- RE에서 NFA를 생성하는 구조적 알고리즘
- ε-transition을 통해 구조적으로 RE를 표현 가능

### ▪ Subset Construction:
- NFA를 DFA로 변환하는 알고리즘
- 상태의 **집합(Subset)** 을 하나의 DFA 상태로 치환

---

## 6. DFA 실행 방식

### ▪ DFA 상태 이동 코드 예시:
```cpp
state ← start
while (input not EOF):
    state ← transition[state, input_char]
if (state is final):
    Accept
else:
    Reject
```



---

## 7. 토큰 판별 규칙 (Longest Match & Priority)

**▪ Rule 1: 가장 긴 토큰이 우선**

​	•	예: **는 <multiply><multiply>가 아닌 <exp>로 인식



**▪ Rule 2: 우선순위 적용**

​	•	예: if는 id보다 우선하여 <if>로 인식



**▪ 구현 의사코드:**

~~~pytho
while s ≠ "":
    idx = 0
    for i in 1 to len(s):
        if s[0:i] matches any token pattern:
            idx = i
    if idx == 0:
        error
    else:
        classify s[0:idx]
        s ← s[idx:]
~~~

