---
layout: single
title: "Compiler - Syntax Analysis(01)"
categories: [CS]
tags: [Compiler]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

- Syntax Analysis는 LL, LR 파싱으로 포스트를 나눴다. 이번 포스트는 Syntax Analysis의 역할과, LL파싱에 대해 다룬다.



# Syntax Analysis (Part 1)

**Syntax** vs **Semantics**

- Syntax(구문) : **형식적 구조, 문법**을 의미
- Semantics(의미) : 코드나 문장이 **무엇을 뜻하는가**에 대한 내용

> Syntax는 의미가 성립하지 않아도 상관이 없음.
>
> 문법만 맞으면 가능! -> 문법 **Context-Free Grammar 사용**



## CFGs

**CFGs (Context-Free Grammars)** : 문맥 자유 문법

- Regualar Language 의 한계

정규 언어는 **Finite State Machine (FSM)** 으로 표현 가능한 언어

FSM은 **기억** 능력이 없기에 **중첩된 구조** 를 처리할 수 없음. 

> **L = { aⁿbⁿ | n ≥ 0 }**
>
> a와 b의 개수가 정확히 같아야 함. 이런 경우에 개수가 정확히 같아야하기에 기억 능력이 없는 Relgular Language는 표현 불가능.



- Grammar

>  G = (V, Σ, R, S)

**Terminal Symbols** : 터미널 기호, 실제 언어에 나타나는 문자들(token)

**Non-terminal Symbols** : syntactic **variable** 

**Start-Symbol** : 문장 생성의 시작점, Non-terminal의 하나

**Productions** : 'productions' (화살표)



- Derivation : 시작기호 S부터 **생성 규칙**을 반복 적용하여 최종적으로 **터미널(실제 문자)**만 남도록 하는 과정
- Sentence : CFG의 **시작 기호로부터 도출 가능한 문자열**
- Language : **모든 Sentence의 집합**

- Sentential Form : CFG에서 **시작 기호로부터 유도되어 나올 수 있는 중간 단계 문자열**을 의미함. 터미널 기호와 논터미널 기호가 섞여 있을 수 있음. 

> CFG는 **nested statement**를 표현할 수 있음. 



## Parsing(파싱)

- 파서는 **토큰 스트림**을 받아 문법적 구조가 유효한지 판단하고 **구문 트리(Parse Tree 또는 AST)** 를 생성함
- 두 가지 목적
  - 문법 체크 (Validity Check)
  - 구문 트리 생성 (Tree Construction)

- Derivations
  - Leftmost Derivation : 항상 **왼쪽의 non-terminal**부터 대체
  - Rightmost Derivation : 항상 **오른쪽의 non-terminal**부터 대체

- Parse Tree
  - **Parent Node**와 **children of a nod**로 구성
  - 트리의 leaves는 항상 **terminal**, non-leaves는 **non-terminal**





- 파싱 시간  `O(n^3)` => **비효율적**이기에 다음 3가지로 효율을 최적화 할 수 있음.

1. **non-Ambiguous**
2. has **no left recursion**
3. has **only one choice of production** starting from a specific input symbol for each non-terminal



### Ambiguity

**Ambiguity (모호성) **이란 하나의 문자열이 **둘 이상의 파싱 트리**를 갖는 경우를 말함. 즉, **문법이 애매하게 해석될 수 있다.**

- 예시)

  E → E + E
     | E * E
     | ( E )
     | id

  - (id + id) * id 로 해석이 가능하고, id + (id * id) 로도 해석이 가능함.



- 모호성을 제거하는 방법

1. **연산자 우선순위 (precedence)** 반영

- 우선순위가 더 높은 연산자를 하위 계층으로 빼야함.

2. **연산자 결합법칙(Associativity)** 반영

- **왼쪽 결합(left-associative)**
- **오른쪽 결합(right-associative)**



대표적 예시 : *if-then-else* 구문 (**dangling else**) 

stmt → if expr then stmt
      | if expr then stmt else stmt
      | other

위 derivation을 통해

`if a then if b then s1 else s2`로 나타낼 수 있음.

- 두 가지 해석 (**Ambigutiy**)

1. else가 가장 가까운 if에 붙는 경우 (정상적 해석)
2. else가 첫 번째 if에 붙는 경우 (모호한 해석)



- 해결 방법 

**각각의 else**를 가장 가까운 **매치되지 않은 then** 과 연결

>stmt         → matched_stmt | unmatched_stmt
>
>matched_stmt → if expr then matched_stmt else matched_stmt  | other
>
>unmatched_stmt → if expr then stmt
>               | if expr then matched_stmt else unmatched_stmt



---

전형적인 파싱에서 (top-down) 시작 symbol로 부터 내려갈 때, 

(여기서부터 이어서) 



### Left Recursion (좌측 재귀)

문법 규칙에서 **자기 자신을 왼쪽에서 재귀적으로 호출하는 것**을 의미함. 

`expr → expr + term | term` 처럼, 무한 재귀에 빠짐. 





---

## 🧭 파싱 알고리즘의 분류

| 전략      | 설명                    | 대표 기법             |
| --------- | ----------------------- | --------------------- |
| Top-down  | 루트에서 리프 방향 생성 | Recursive Descent, LL |
| Bottom-up | 리프에서 루트 방향 생성 | Shift-Reduce, LR, SLR |

---

## 🔼 Top-Down Parsing (LL)

### ✔️ Recursive Descent Parsing

- 가장 단순한 top-down 파싱
- 각 비터미널에 대해 재귀적으로 호출
- **Backtracking** 필요 (비효율적일 수 있음)
- CFG 조건:
  - 비모호
  - **Left-recursion 없음**
  - Left-factoring 있으면 효율성 ↑

---

## 🔮 LL(1) 파싱 (Predictive Parsing)

- **Backtracking 없는** Top-down 파싱
- `L1`: Left-to-right scanning
- `L2`: Leftmost derivation
- `1`: One-token lookahead

### ✔️ LL(1) 문법 조건
- 비모호하고
- Left-recursion이 없으며
- Left-factored 되어 있음

---

## 🔤 FIRST & FOLLOW 집합

### ✔️ FIRST(A)
- A로부터 시작되는 문자열의 첫 번째 terminal 집합
- A → α 에 대해, α가 ε을 유도하면 ε도 포함

### ✔️ FOLLOW(A)
- 어떤 문자열 S ⇒ αAβ 에서 **A 뒤에 올 수 있는 terminal 집합**
- 시작 기호의 FOLLOW 집합에는 `$` 포함

---

## 🧮 LL(1) 파싱 테이블 생성 방법

1. 각 생산 규칙 A → α 에 대해:
   - `FIRST(α)`의 모든 terminal `a`에 대해 `M[A, a] = A → α`
   - ε ∈ FIRST(α)인 경우, `FOLLOW(A)`의 모든 `b`에 대해 `M[A, b] = A → α`

2. 테이블을 기반으로 파싱 수행

---

## 🧰 LL(1) 파서 구현 절차

1. Stack에 **시작 기호**와 **$** 푸시
2. Stack top이:
   - Terminal → 입력 심볼과 비교
   - Non-terminal → 파싱 테이블 참고하여 대응되는 규칙 적용
3. 입력이 끝나고 stack도 비면 **Accept**

---

## ✅ LL(1) 파싱 요약

| 항목             | 설명                               |
| ---------------- | ---------------------------------- |
| 속도             | 빠름 (`O(n)`)                      |
| CFG 요구 조건    | 비모호, 좌재귀 없음, left-factored |
| Backtracking     | 없음                               |
| 테이블 기반 파싱 | 예측 가능하고 단순한 구현 가능     |

---

## 📝 정리 요약

- Top-down Parsing:
  - 간단하지만 Backtracking으로 인해 비효율적일 수 있음
- LL(1) Parsing:
  - Backtracking 없이 선형 시간에 파싱 가능
  - CFG는 명확한 조건을 만족해야 함

