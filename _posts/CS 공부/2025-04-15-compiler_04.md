---
layout: single
title: "Compiler - Syntax Analysis(03)"
categories: [CS]
tags: [Compiler]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

이번에는 Syntax Analysis의 Bottom-up Parsing과 Shift-reduce parsing과 LR(0), SLR(1) parsing에 대해 다룬다. 



# Syntax Analysis (Part 3) 

---

## Bottom-Up Parsing

Parse trees가 **bottom** up to the **top** (leaves -> root)

(장점)

Top-Down **LL(1)** 문법만 처리가 가능 (제약이 많음)

- Bottom-Up 은 **LR, LALR, SLR** 등 더 많은 문법을 처리 가능

-> 즉, **left-recursive, ambiguous**한 문법도 처리가 가능함.

- **모호성 제거에 유리**

-> shift/reduce , reduce/reduce conflict 명시적 해결이 가능

-> 따라서 **우선 순위와 결합 규칙을 명확히 적용** 가능함.

(단점)

- **구현 복잡도가 더 높음**



### Shift-Reduce Parsing

**LR Parsing**

- L : **Left-to-Right scanning of input**
- R : **Rightmost derivation**



Shift-Reduce Parsing의 개념

: 입력 문자열을 **오른쪽에서 왼쪽으로 줄여 나가며** 최종적으로 시작 기호 S 하나로 만드는 방식 

- 입력 문자열을 **Shift(이동)** 또는 **Reduce(축소)** 하며 파싱을 진행
- **Rightmost Derivation in Reverse**를 따름
- 입력을 `왼쪽부터 읽고`, `우측 유도 과정을 역순`으로 수행



**핵심 Key idea**

#### Splitter

- 파서가 **입력 스트링을 둘로 나누는 지점**
- 이 지점을 기준으로 왼쪽은 **지금까지 처리한 부분(stack)**, 오른쪽은 **아직 남은 입력**
- 파서가 매번 **shift / reduce**를 결정

> `|` 기호를 사용 => Union이랑 헷갈리지 말 것 



#### Left Substring 

- 지금까지 **Shift된 부분 문자열**
- **파싱 스택에 쌓인 심볼**들로 이 부분에서 규칙을 찾아 **Reduce**를 할 수 있음. 



#### Right Substring

- 아직 **읽지 않은 입력** (**a sequence of terminal**)
- 아직 Shift 되지 않은 심볼들의 나머지 부분으로 파서는 이 부분을 읽으며 계속 스택을 채워 나감. 



### Shift - Reduce 작동 방식

| 작업   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| Shift  | 입력 토큰을 스택으로 이동                                    |
| Reduce | 스택 상단의 문자열이 production RHS와 일치할 경우, 이를 LHS로 치환 |



### Conflict

- **Shift/Reduce Conflict**

**파서가 어떤 시점에서** *Shift or Reduce*를 해야 할지 **결정하지 못할 때 발생하는 충돌**

지금 줄일까? 아니면 더 읽을까? 를 결정하지 못해서 충돌이 생김. 

예시)

stmt → if expr then stmt | if expr then stmt else stmt

> Input : if E1 then if E2 then S1 else S2

​	두 가지의 가능한 해석 

1. **Reduce**

   먼저 if E2 then S1 을 하나의 stmt로 보고

   → if E1 then stmt 로 reduce 하려는 경우

2. **Shift**

   아직 else가 남아 있으니

   → 더 많은 토큰을 읽기 위해 shift 하려는 경우



- **Reduce / Reduce Conflict**

**두 개 이상의 production을 동시에 reduce할 수 있을 때 발생하는 충돌**로 파서가 여기서 어떤 규칙을 사용해 줄여야하는지 둘 이상의 후보로 두고 결정을 하지 못하고 있는 상황

예시) 

A → α  
B → α
S → A | B

Input 이 α 일 때, **A로 줄일지, B로 줄일지** 파서가 결정을 못하는 상황 

=> 둘 다 reduce가 가능하기에 **conflict 발생**



## Handle & Viable Prefix

어떻게 Shift or Reduce를 결정해야할까? 

: **Reduce를 해도 그 결과가 결국 시작 기호(Start Symbol)로 줄여질 수 있을 때만 Reduce를 해야한다**

### Handle

현재 파싱 문자열에서 **하나의 production rule을 적용하여 줄일 수 있는 우변 부분**을 의미함. 

현재 줄일 수 있는 **RHS에 완전히 일치하는 부분 문자열**

> Handle = **우변(β)의 instance**
>
> 즉, 파싱 중인 문자열에서 **한 번의 reduce로 좌변(A)으로 바뀔 수 있는 부분** 

- Bottom-up parser는 **항상 Handle을 찾아서 reduce**함.
- LR Parser가 정확히 **Handle의 위치를 결정**해주는 알고리즘

(특징)

**Handle은 항상 Stack의 Top에 있다.**

- Shift-Reduce 방식은 **입력을 오른쪽에서 왼쪽으로 파싱**하는 과정
- 그래서 제일 **최근에 만들어진 것(=handle)은 항상 Stack의 위쪽에 존재**하게 됨. => 편리한 성질
  - 따라서 **Unambiguous CFG일때**, Shift-Reduce Parser는 **handle에서만 reduce** 해야함. 



요약 : Handle = **줄일 준비가 된 부분**

*파서 입장에서 '여기서 줄여도 괜찮을까'에 대한 판단 기준*



### Viable Prefix

(여기서 부터 이어서 하기) 







- 유효한 왼쪽 접두어**
- 어떤 정상적인 파싱 과정에서도 나타날 수 있는 **스택 상태**
- **핸들을 포함하는 문자열로 끝남**

---

## LR(0) Parsing

### ✔️ 특징
- DFA(유한 오토마타)를 사용하여 viable prefix 인식
- **Lookahead 없이** Reduce 결정
- 충돌 발생 가능성 있음

### ✔️ 동작 규칙
- 상태 I에 `< A → α . >` 아이템이 있으면 → Reduce
- 상태 I에서 다음 심볼에 대해 전이 있으면 → Shift

---

## SLR(1) Parsing (Simple LR)

### ✔️ 특징
- **LR(0)** 기반 + **FOLLOW 집합** 활용
- **1-step lookahead** 사용 → 충돌 감소
- 여전히 일부 문법은 처리 불가

### ✔️ 동작 규칙
- 상태 I에 `< A → α . >` 아이템이 있고, lookahead ∈ FOLLOW(A) → Reduce
- 상태 I에서 다음 심볼에 대해 전이 있으면 → Shift

---

## 구현 요약

- **DFA** 구성: 아이템 집합으로 상태 구성
- **핸들 인식**: 아이템의 dot 위치 기반
- **파싱 테이블** 생성 필요 (ACTION & GOTO)

---

## 요약 정리

| 구분          | 설명                                     |
| ------------- | ---------------------------------------- |
| Bottom-Up     | 입력을 하단부터 파싱 (Shift-Reduce 기반) |
| Handle        | 줄일 수 있는 현재 RHS 부분 문자열        |
| Viable Prefix | 어떤 파싱 과정에서도 가능한 스택 상태    |
| LR(0)         | 충돌 위험 있음, Lookahead 없음           |
| SLR(1)        | FOLLOW 집합 활용, 충돌 줄임              |

---

