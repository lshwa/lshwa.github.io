---
layout: single
title: "Compiler - Syntax Analysis(03)"
categories: [CS]
tags: [Compiler]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

이번에는 Syntax Analysis의 Bottom-up Parsing과 Shift-reduce parsing과 LR(0)에 대해 다룬다. SLR() 파싱은 Syntax Analysis 장에서의 마지막 Part4로 다룰 것이다. 



# Syntax Analysis (Part 3) 

---

## Bottom-Up Parsing

Parse trees가 **bottom** up to the **top** (leaves -> root)

(장점)

Top-Down **LL(1)** 문법만 처리가 가능 (제약이 많음)

- Bottom-Up 은 **LR, LALR, SLR** 등 더 많은 문법을 처리 가능

-> 즉, **left-recursive, ambiguous**한 문법도 처리가 가능함.

- **모호성 제거에 유리**

-> shift/reduce , reduce/reduce conflict 명시적 해결이 가능

-> 따라서 **우선 순위와 결합 규칙을 명확히 적용** 가능함.

(단점)

- **구현 복잡도가 더 높음**



### Shift-Reduce Parsing

**LR Parsing**

- L : **Left-to-Right scanning of input**
- R : **Rightmost derivation**



Shift-Reduce Parsing의 개념

: 입력 문자열을 **오른쪽에서 왼쪽으로 줄여 나가며** 최종적으로 시작 기호 S 하나로 만드는 방식 

- 입력 문자열을 **Shift(이동)** 또는 **Reduce(축소)** 하며 파싱을 진행
- **Rightmost Derivation in Reverse**를 따름
- 입력을 `왼쪽부터 읽고`, `우측 유도 과정을 역순`으로 수행



**핵심 Key idea**

#### Splitter

- 파서가 **입력 스트링을 둘로 나누는 지점**
- 이 지점을 기준으로 왼쪽은 **지금까지 처리한 부분(stack)**, 오른쪽은 **아직 남은 입력**
- 파서가 매번 **shift / reduce**를 결정

> `|` 기호를 사용 => Union이랑 헷갈리지 말 것 



#### Left Substring 

- 지금까지 **Shift된 부분 문자열**
- **파싱 스택에 쌓인 심볼**들로 이 부분에서 규칙을 찾아 **Reduce**를 할 수 있음. 



#### Right Substring

- 아직 **읽지 않은 입력** (**a sequence of terminal**)
- 아직 Shift 되지 않은 심볼들의 나머지 부분으로 파서는 이 부분을 읽으며 계속 스택을 채워 나감. 



### Shift - Reduce 작동 방식

| 작업   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| Shift  | 입력 토큰을 스택으로 이동                                    |
| Reduce | 스택 상단의 문자열이 production RHS와 일치할 경우, 이를 LHS로 치환 |



### Conflict

- **Shift/Reduce Conflict**

**파서가 어떤 시점에서** *Shift or Reduce*를 해야 할지 **결정하지 못할 때 발생하는 충돌**

지금 줄일까? 아니면 더 읽을까? 를 결정하지 못해서 충돌이 생김. 

예시)

stmt → if expr then stmt | if expr then stmt else stmt

> Input : if E1 then if E2 then S1 else S2

​	두 가지의 가능한 해석 

1. **Reduce**

   먼저 if E2 then S1 을 하나의 stmt로 보고

   → if E1 then stmt 로 reduce 하려는 경우

2. **Shift**

   아직 else가 남아 있으니

   → 더 많은 토큰을 읽기 위해 shift 하려는 경우



- **Reduce / Reduce Conflict**

**두 개 이상의 production을 동시에 reduce할 수 있을 때 발생하는 충돌**로 파서가 여기서 어떤 규칙을 사용해 줄여야하는지 둘 이상의 후보로 두고 결정을 하지 못하고 있는 상황

예시) 

A → α  
B → α
S → A | B

Input 이 α 일 때, **A로 줄일지, B로 줄일지** 파서가 결정을 못하는 상황 

=> 둘 다 reduce가 가능하기에 **conflict 발생**



## Handle & Viable Prefix

어떻게 Shift or Reduce를 결정해야할까? 

: **Reduce를 해도 그 결과가 결국 시작 기호(Start Symbol)로 줄여질 수 있을 때만 Reduce를 해야한다**

### Handle

현재 파싱 문자열에서 **하나의 production rule을 적용하여 줄일 수 있는 우변 부분**을 의미함. 

현재 줄일 수 있는 **RHS에 완전히 일치하는 부분 문자열**

> Handle = **우변(β)의 instance**
>
> 즉, 파싱 중인 문자열에서 **한 번의 reduce로 좌변(A)으로 바뀔 수 있는 부분** 

- Bottom-up parser는 **항상 Handle을 찾아서 reduce**함.
- LR Parser가 정확히 **Handle의 위치를 결정**해주는 알고리즘

(특징)

**Handle은 항상 Stack의 Top에 있다.**

- Shift-Reduce 방식은 **입력을 오른쪽에서 왼쪽으로 파싱**하는 과정
- 그래서 제일 **최근에 만들어진 것(=handle)은 항상 Stack의 위쪽에 존재**하게 됨. => 편리한 성질
  - 따라서 **Unambiguous CFG일때**, Shift-Reduce Parser는 **handle에서만 reduce** 해야함. 



요약 : Handle = **줄일 준비가 된 부분**

*파서 입장에서 '여기서 줄여도 괜찮을까'에 대한 판단 기준*



### Viable Prefix

**핸들을 포함하거나, 핸들 바로 앞까지만 포함하는 접두사**

> **Left Substring** that can appear during shif-reduce parsing of an **acceptable** input string

- **Shift-Reduce Parsing 도중에 올 수 있는 ** "정당한" 입력 문자열의 왼쪽 부분 문자열로 **핸들이 오기 전까지** 또는 **핸들을 막 포함한 시점까지의 ** 모든 중간 결과들을 말함. 

더 완성된 문장임을 알기 위해 **더 읽어보고** 완성된 문장인지 판단하는 것과 같음.



예시) 

| **상태** | **판단 기준** | **이유**            |
| -------- | ------------- | ------------------- |
| `F       | * id`         | **Shift**           |
| `F *     | id`           | **Shift**           |
| `F * id  | `             | **Reduce** (id → F) |

F는 T-> F 로 **reduce** 할 수 있는 핸들처럼 보이지만, 그 다음에 * 가 오고 있기 때문에 지금은 아직 **핸들이 아님**

=> 파서가 **충분한 정보를 얻기 전까지는 Shift를 계속 수행하고, 핸들이 확실해지면 그 때 Reduce를 하는 방식**으로 수행.



- Viable Prefix를 인식하는 방법

Viable Prefix는 여러 개의 **생성 규칙 오른쪽 (RHS)** 의 접두사들이 **붙어서 생긴 형태**라는 것 

> 정확한 기준 
>
> **어떤 Viable Prefix가 어떤 production의 RHS의 전체(완전한 우변)를 만들었는가?**

만약 완전한 우변을 만들었을 때, **Reduce가 가능함.**

* 인식 방법 요약 
  * **Incomplete RHS** : 아직 완성되지 않은 경우이기 때문에 아직 Reduce가 불가능함.
  * **Eventually Reduce** : 계속 Shift를 하다보면 결국 Reduce를 할 수 있음.
  * 한 개 이상이면 일단 Shift : RHS가 완성되지 않으면 **계속 Shift 하는게 원칙** 이라는 뜻



- Viable Prefix 요약 

1. Shift-Reduce Parsing 에서 **Stack에 push 되는 것**들이 모두 **Viable Prefix**이여야 함. 
2. 이 개념을 바탕으로 **파싱 상태(state)를 정의하고 DFA를 구성**
3. Viable Prefix를 인식하는 DFA가 **핸들 인식의 기초**



#### Item

Viable Prefix를 인식하는 방법의 새로운 개념

문법의 **production rule에 점 (dot)을 찍어 현재 분석 상태를 나타내는 형태**를 말함. 

>  Viable Prefix는 스택에 있는 문자열이 올바른 핸들 앞부분인지를 판단함.

그 판단을 위하여 **점(dot)을 사용해 현재 분석 위치를 명시**함. 그래서 **Item의 집합을 이용해서 Viable Prefix들을 구별하고**, shift/reduce 동작을 결정할 수 있음.  



#### Viable Prefix To NFA 인식

Viable Prefix를 인식하는 NFA(비결정적 유한 오토마타)를 만드는 방법

1. **새로운 시작 규칙 추가**

`S' → S`

- 기존의 시작 심볼 **S를 새로운 시자 심볼 S'**로 바꿔줌.
- 모든 파싱의 시작은 이 S' 에서 시작함.



2. **NFA의 구성요소**

- **States** : CFG에서 G에서 모든 **items** (시작 규칙도 포함)
- **Alphabet** : G에 등장하는 모든 기호들
- **Start State** : 시작 규칙
- **모든 State는 accept state** : (Viable Prefix는 어느 지점에서도 유효하기 때문) 



3. **Transition 만들기**

> 예시 )  
>
> From: E → α • X β  
> To:   E → α X • β  
> On:   input X



3-1 . **Transition 만들기 - (ε-move)**

- dot 앞의 X가 non-terminal이고, 해당 production이 존재하면, **ε-transition**으로 새로운 item들을 추가해줌 (Closure 확장)



* NFA -> DFA
  * **NFA 상태는 "단일 item"**
  * **DFA 상태는 ""item들의 closure 집합**
  * **DFA transition은 dot을 terminal 또는 non-terminal 기호 뒤로 옮긴 결과**
  * **이동한 item으로부터 다시 closure 수행**

위 과정을 반복하면 결과적으로

- DFA = LR(0) Automation
- 각 상태 = 여러 item들의 모음
- Transition = dot 오른쪽 심볼을 기준 



---

## LR(0) Parsing

- DFA(유한 오토마타)를 사용하여 viable prefix 인식
- **Lookahead 없이** Reduce 결정
- 충돌 발생 가능성 있음



### 동작 규칙
- 상태 I에 `< A → α . >` 아이템이 있으면 → Reduce
- 상태 I에서 다음 심볼에 대해 전이 있으면 → Shift

