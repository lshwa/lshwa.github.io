---
layout: single
title: "Algorithms : Backtracking"
categories: [CS]
tags: [Algorithm]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

이번 포스트에서는 Backtracking 이라는 알고리즘에 대해 설명한다. 



## Greedy VS Dynamic Programming

**왜 Greedy 알고리즘이 중요한가?**

- **Heuristic**기반 (경험지식에서 가져온다.)
- 간단하고, 빠르고, 구현에 용이하다. 
- 새로운 문제의 baseline 전략으로 유용하다.
- Optimal한 Substructure가 있다면 global Optimal도 가능하다. 
  - 물론 증명은 필요하다. 



### Knapsack Problem

**문제 정의**

- **Input** : 아이템 n개가 있고, 각 아이템마다 Weight 와 Profit이 존재한다. W로 총 용량도 존재한다. 
- **Goal** : weight의 총합이 W보다 작음을 만족하면서 Profit을 최대화하는 Subset A를 찾아라 

- 응용 예시 
  - 도둑 가방 문제 
  - 스타트업 투자 문제 (투자금의 제약 -> 최적이 아이템 조합 )

- 해결 방법 비교 

1. **Brute Force (BF)** : 모든 경우를 탐색한다. 성능은 매우 느리다. 
   $$
   O(2^n)
   $$

2. **Divide & Conquer** : Optimal을 찾을 수는 있지만, 효율적이지 않다. 

3. **Dynamic Programming** : Optimal을 보장한다. 
   $$
   O(nW)
   $$

4. **Greedy** : 빠르다, 일부 경우에만 Optimal 하다. (Fractional 가능)
   - 0/1 Knapsack에서는 Optimal 하지 않다. 



#### Greedy idea 접근

1. **Profit** 기준으로 정렬 

- Profit이 높은 item 부터 넣는다. 
- KnapSack 용량이 초과될 수도 있다. -> 그렇기에 profit 기준으로만 넣는다고 할 때 **반례가 생긴다.**



2. **Profit per Unit Weitght** 기준 정렬

- 각 아이템의 **가치 / 무게 비율**을 기준으로 정렬해서 넣는다. 
- Fractional Knapsack과 같이 쪼개서 넣는 경우가 가능할 때는 이 방법이 가장 효율이 높다.
- 하지만, 어떤 경우에도 비율이 낮은 아이템을 하나만 넣는 것 전체 profit 보다 클 수 있다. 
  - 따라서 0/1 Knapsack에서는 **DP를 사용해야 Optimal을 보장할 수 있다.**



#### DP Design

Knapsack 문제는 **Optimal Substructure와 Overlapping Subproblem**을 만족한다. 

**1D Array에서는 실패한다.**

- weight 조건을 고려하지 못해서 단순히 아이템을 몇개까지 선택했는가 만을 가지고서는 최적해를 만들 수 없다. 

- 따라서 2차원 배열이 필요하다.



**2D Array**

- 1차원 : Item Index (몇 번째 아이템까지 고려했는가?)
- 2차원 : Weight (현재까지의 총 무게가 얼마인가?)



> DP Table

- **p[i , w] = item 1 ~ i 까지 고려했을 때, 총 weight <= W인 경우 얻을 수 있는 최대 profit**

- **Recurrence Relation**
  $$
  p[i, w] = \max \Big( p[i-1, w],\ p[i-1, w - w_i] + p_i \Big)
  $$

- 해석 : 두 가지 경우 중에 더 좋은 것을 선택한다. 
  - **Item i를 넣지 않은 경우** : 이전 결과를 그대로 사용한다. 
  - **Item i를 넣는 경우** : 이전의 용량으로 만들었던 best 결과에 Profit을 추가한다. 



#### DP Anlaysis

**Time Complexity**

- DP에서 사용한 table은 p[i,w] 인 2차원 테이블이다. 

- 즉 table의 크기는 `n X W` 이다. 

- 전체 시간복잡도
  $$
  O(n \times W)
  $$
  

- Space Complexity 
  - 기본적으로 n X W 공간이 필요하다. 
  - 최적화하면 O (W) 공간으로 줄일 수 있다.



**Pseudo - Polynomial Time**

- 입력 크기 n은 **item의 개수**
- W는 입력이 아니라 **숫자 값**이다. 
- W가 너무 큰 수가 나와버리면 시간 복잡도가 실질적으로 매우 커진다. 



> **DP Optimization Idea**
>
> - 모든 p[i,w]를 반드시 계산할 필요는 없다. 
> - 현재 남은 weight가 w < w_i 인 경우에는 Item_i를 넣을 필요가 없다.
> - 즉, 일부 경우에는 **row마다 현재 가능한 weight 구간만 계산**하도록 최적화가 가능하다. 
> - 문제 본질이 **Hard (NP - Hard)** 부분에 속한다.

-> 따라서 더 큰 Scale의 문제를 풀기 위해서는 새로운 **Algorithm이 필요하다.**



# Backtracking

