---
layout: single
title: "Process (API)"
categories: [OS]
tags: [운영체제]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"

---

이번 포스트는 운영체제의 Process와 Process API에 대해 학습한다.



# Process

> **CPU 가상화**
>
> - How to provide the illusion of many CPUs?
>
> (어떻게 하나의 실제 CPU로도, 여러 프로그램이 동시에 실행되는 '착각'을 만들어낼 수 있을까?)



**CPU 가상화 (CPU virtualizing)**

- OS는 **여러 개의 가상 CPU (Virtual CPU)가 존재**하는 것처럼 착각을 만들어냄.
- 실제로는 하나의 CPU가 존재하지만, OS가 빠르게 작업을 번갈아가면서 **(time - sharing)**을 실행하여 마치 동시에 돌아가는 것처럼 보이게 함. 



## A Process

`A process is a running program`

> **프로세스란 실행 중인 프로그램이다.**



**Program vs Process**

| **구분** | **프로그램 (Program)**                   | **프로세스 (Process)**        |
| -------- | ---------------------------------------- | ----------------------------- |
| 상태     | 정적인 존재 (디스크에 저장된 파일)       | 동적인 존재 (실행 중)         |
| 위치     | 보통 **disk** (예: 실행 파일 .exe, .out) | **메모리** (RAM 안)           |
| 특징     | 명령어 집합(instruction set) 그 자체     | OS가 CPU 위에서 실행 관리     |
| 예시     | “Chrome.exe” 파일                        | 실행 중인 여러 Chrome 탭 각각 |



→ 즉, **프로그램은 아직 실행되지 않은 코드의 묶음**

→ 프로세스는 그 프로그램이 **메모리에 올라와서 CPU에서 실행 중인 상태**



**프로세스의 구성 요소**

**1. Memory**

- 프로세스가 사용할 **주소 공간**을 의미
- 세부 구성
  - **Instructions** : 실행할 명령어 코드 
  - **Data section** : 전역 변수, 상수 등



**2. Registers**

- CPU 내부에서 실행 중인 프로세스의 상태를 저장하는 **작은 메모리**
- 주요 구성
  - **Program Counter (PC)** : 다음에 실행할 명령어의 주소
  - **Stack Pointer (SP)** : 현재 함수 호출 스택의 위치 



**Process API**

- OS가 제공하는 **프로세스 제어 인터페이스**
  - **Create** : 새로운 프로세스를 실행하여 프로그램을 실행시킴. 
  - **Destroy** : 실행 중인 프로세스를 강제로 종료
  - **Wait** : 특정 프로세스가 종료될 때까지 기다림
  - **Miscellaneous Control** : 프로세스를 일시 중단했다가 나중에 재게하는 기능
  - **Status** : 프로세스의 상태, CPU 사용량, 실행 여부 등을 확인



### Process Creation

프로세스 생성 (Process Creation)의 전 과정

> 전체 개요
>
> **Program -> Memory -> CPU**
>
> **로딩 -> 초기화 -> 실행**

요약

**프로그램이 프로세스로 바뀌는 과정은 OS가 '주소 공간을 구성하고 실행을 시작하는' 단계적 절차다.**



![Process](/../images/2025-10-06-OS_1/Process.png)

**1. Load a program code into memory**

- **디스크에 있는 프로그램을 메모리로 불러오기**
  - 프로그램은 디스크에 **실행 파일**로 저장되어 있음.
  - OS는 이 코드를 **주소 공간 (Address Space)**에 올려서 프로세스로 바꿈.

- **Lazy Loading**
  - 게으르게 로드한다. 
  - **천천히 가져온다는 것이 아닌 필요할 때만** 로드한다는 의미
  - 프로그램 전체를 한 번에 다 메모리에 올리는 것이 아니라 실행 중 필요한 부분만 조금씩 불러옴. 



**2. The program's run-time stack is allocated.**

- **런타임 스택 생성**
  - 스택은 **함수 호출, 지역 변수, 매개 변수, 반환 주소를 저장하는 공간**
  - 프로그램이 실행되면 OS가 스택  공간을 자동으로 만들어줌.



**3. Create the heap**

- **동적 메모리 영역 생성**
  - **Heap** 은 **실행 중(runtime)에 동적으로 할당되는 메모리 공간**
  - `malloc( ), new`등을 통해서 생성하고 `free( ) or delete`로 해제하지 않으면 **메모리 누수 (memory leak)**이 발생함. 



**4. Other initialization tasks**

- **기타 초기화 작업**
  - OS가 하는 I/O 설정
  - 모든 프로세스는 기본적으로 **세 개의 파일 디스크립터**를 가진다. 
    - `stdin, stdout, stderr`



**5. Start the program**

- **프로그램의 진입점 entry point에서 실행 시작**
  - 대부분의 프로그램은 **main( ) 함수**를 진입점으로 가짐.
  - OS는 CPU 제어권을 새로 만들어진 프로세스에 넘김. 



### Process State

하나의 Process 는 실행 중에 여러 상태를 오가며 변화한다. 

OS는 이 상태를 관리하면서 CPU를 어떤 프로세스에게 줄지 결정한다. 

**1. Running**

- 현재 CPU 위에서 실제로 실행 중인 상태 (**활성 상태**)
- CPU는 **한 번에 단 하나의 프로세스만 실행**할 수 있음.



**2. Ready**

- 실행할 준비는 되었지만, CPU를 아직 받지 못한 상태
- **CPU만 배정되면 바로 실행할 수 있는 상태**



**3. Blocked**

- 입출력(I/O) 같은 작업 때문에 CPU가 필요 없어 잠시 멈춘 상태
- 이 동안 CPU는 다른 프로세스에게 넘어감 
  - CPU 자원 낭비 방지 



### Data Structures

**PCB (Process Control Block)**

- 운영체제가 **각 프로세스의 상태 정보를 저장**하기 위한 자료구조
  - 커널 내부에 존재하는 **C 구조체** 형태의 데이터
- **Register Context** : 현재 프로세스가 CPU에서 어떤 레지스터 값을 가지고 있었는가를 저장한 것 



**Process List**

- OS가 관리 중인 모든 프로세스의 **PCB들을 연결해둔 리스트** 구조
  - Ready List, Blocked List, Running Process 



**예제 코드 분석**

~~~c
struct context {
  int eip;  // Instruction Pointer
  int esp;  // Stack Pointer
  int ebx;  // Base Register
  int ecx;  // Counter Register
  int edx;  // Data Register
  int esi;  // Source Index Register
  int edi;  // Destination Index Register
  int ebp;  // Stack Base Pointer Register
};
~~~

- xv6가 **프로세스를 멈출 때**, 위의 레지스터 값들을 저장해 두었다가 나중에 다시 **복원함.**
- 이 값들이 바로 PCB 내부의 Register Context 부분



~~~c
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
~~~

- **프로세스의 상태 코드**들



~~~c
struct proc {
  char *mem;           // 프로세스 메모리 시작 주소
  uint sz;             // 메모리 크기
  char *kstack;        // 커널 스택
  enum proc_state state; // 프로세스 상태
  int pid;             // 프로세스 ID
  struct proc *parent; // 부모 프로세스
  void *chan;          // Blocked 상태일 때 대기하는 채널
  int killed;          // 종료 요청 여부
  struct file *ofile[NOFILE]; // 열린 파일들
  struct inode *cwd;   // 현재 작업 디렉터리
  struct context context; // 레지스터 상태 저장
  struct trapframe *tf;   // 인터럽트 프레임
};
~~~

- 현실 운영체제의 PCB 구조체와 거의 동일한 개념





# Process API





