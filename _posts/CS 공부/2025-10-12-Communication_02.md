---
layout: single
title: "컴퓨터 통신 02.데이터 링크 네트워크 (Data Link Network)"
categories: [Network]
tags: [컴퓨터 통신]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

이번 포스트에서는 컴퓨터 통신의 데이터 링크 네트워크에 대해 다룬다. 자세한 목차는 아래와 같다. 

1. 점대점 (Point-To-Point) 링크
   - 하드웨어 구성요소
   - 인코딩
   - 프레이밍
   - 오류검출
2. 신뢰성 있는 전송
3. 이더넷 / FDDI
4. 네트워크 어댑터



**Overview**

> 네트워크 전체가 아니라, **직접 연결된 두 노드 간**의 데이터 전달은 어떻게 이뤄질까?

물리 계층은 신호를 전송 (인코딩, 전압 변조 등)하면 **떼이터 링크 계층은 프레임을 사용하여 에러 검출하고 복구, 흐름 제어, 매체 접근 제어**를 수행한다. 

- 1 계층 : **비트 보내기**
- 2 계층 : **그 비트들을 묶어서 의미 있는 프레임으로 전송**



# 데이터 링크 네트워크

## 점대점 링크

### 하드웨어 구성요소

#### 노드 (Nodes)

- **노드 (Node)** : 네트워크에 연결되어 데이터를 주고받을 수 있는 장치
  - (예 : 단말, 호스트, 라우터, 스위치 등)
- 대부분은 **컴퓨터 구조 기반의 시스템**으로, **CPU + Cache + Memory + NIC (Network Interface Card)**로 구성됨.
- 데이터 링크 계층의 실제 구현은 **NIC (네트워크 어댑터)** 안에서 이루어짐. 



**NIC (Network Interface Card)**

- CPU와 네트워크 사이의 "통역사" 역할
  - 프레임 생성, 전송, 수신, 오류 검출 등 처리
  - 버퍼 공간이 제한적 (유한 메모리)
  - OS 커널의 네트워크 스택과 직접 통신 



#### 링크 (Link)

- 노드 간 **데이터 (신호)**를 전달하는 **물리적 매체 (Physical medium)**
  - (예 : 케이블 (유선) 또는 전파(무선))
- 즉, 비트를 실제로 전달하는 통로 
- 하나의 케이블에 **여러 논리적 링크**의 존재가가능 
- 전송 모드
  - **Simplex (단방향)** : 한쪽만 전송 가능 (방송, 센서 등)
  - **Half-Duplex (반이중)** : 양방향이 가능하나 **동시에는 불가** (무전기)
  - **Full-Duplex (전이중)** : 양방향이 **동시에 가능** (대부분의 유선 통신 : 이더넷 등)



#### 모듈레이션 (Modulation)

- 디지털 데이터 (0과 1)를 **전송 매체에 맞는 신호로 바꾸는 과정**
  - 송신 측 : **Modulation** / 수신 측 : **Demodulation**
  - 두 단계를 모두 수행하는 장치 = **Modem**
- 신호의 형태
  - **아날로그 신호** : 연속적 파형, 시간에 따른 연속 변화
  - **디지털 신호** : 이산적 변화, 0 과 1의 단계적 값

> 파장과 주파수는 서로 반비례 (같이 움직이는 관계)



**전자기 스펙트럼과 매체 특성**

- 모든 통신은 **전자기파 (Electromagnetic wave)**를 사용한다. 
- **주파수가 높을수록 파장이 짧다.**
  - 전송 대역폭이 넓어지고 데이터 속도도 향상한다.
  - 다만 전파 손실이 커지고 장애물 통과에 어렵다. 

| **구간**                    | **주파수대**     | **주요 용도**         | **특성**                 |
| --------------------------- | ---------------- | --------------------- | ------------------------ |
| **Radio (10⁴~10⁸ Hz)**      | 장파, 단파       | 방송, 무전            | 장애물 통과, 대역폭 좁음 |
| **Microwave (10⁸~10¹¹ Hz)** | 마이크로파       | 위성, Wi-Fi, LTE      | 고속 전송, 직진성 강함   |
| **Infrared (10¹² Hz 부근)** | 적외선 통신      | 리모컨, 단거리        | 간섭 적지만 거리 짧음    |
| **Visible~UV**              | 광통신, 광케이블 | 광섬유                | 초고속, 감쇠 적음        |
| **X-ray 이상**              | 의료, 특수       | 데이터통신에는 부적합 | 에너지 너무 높음         |



**유선 링크**

- 데이터를 전송하는 **유선 매체의 종류에 따라** 속도와 거리 비용이 달라진다. 

직접 설치가 가능한 케이블

| **종류**                       | **전송속도**    | **거리 한계** | **특징**                   |
| ------------------------------ | --------------- | ------------- | -------------------------- |
| **Cat5/Cat7 Twisted Pair**     | 10 Mbps~10 Gbps | 100m          | 근거리 LAN, 저비용         |
| **Coaxial Cable (Thick/Thin)** | 10~100 Mbps     | 200~500m      | 노이즈 적고 중간 정도 거리 |
| **Multimode Fiber**            | ~100 Mbps       | ~2 km         | 다중 경로 → 감쇠 빠름      |
| **Single-mode Fiber**          | ~1 Gbps↑        | ~40 km↑       | 단일 경로 → 장거리 고속    |

전화 회선 임대형 링크

| **서비스** | **대역폭**            | **용도**               |
| ---------- | --------------------- | ---------------------- |
| ISDN       | 64 Kbps               | 옛날 음성 데이터 겸용  |
| T1         | 1.544 Mbps            | 기업용 전용선          |
| T3         | 44.736 Mbps           | 백본급                 |
| STS 계열   | 51.84 Mbps ~ 2.4 Gbps | 고속 백본 (SONET 기반) |

> 전용선을 임대할 때는 **MUX (다중화기)**를 이용하여 여러 회선을 병합하여 전송한다. 

> 참조 :  광 케이블 (Optical Fiber)

**구조**

- **코어 (Core)** : 빛이 전송되는 유리/플라스틱 중심부
- **클래딩 (Cladding)** : 코어 외부를 둘러싸며 전반사로 빛을 가둠
  - 반사율은 굴절률에 의해 결정한다. 
- 종류 
  - **멀티모드 : 코어가 굵음** (여러 경로로 신호 간섭, 짧은 거리)
  - **싱글모드 : 코어가 얇음** (한 경로로만 전송돼서 감쇠가 적고, 장거리 가능)

---

#### 가입자 선로 (Last-Mile Links)

- **집 (사용자) <-> 통신사** 사이의 연결 구간
- 전체 네트워크 중 가장 **사용자 환경에 직접적인 영향**을 미친다. 

**과거** : 전화선을 이용한 아날로그 통신으로 초기에는 **음성 전화선(아날로그)**를 사용, 전화와 데이터 통신이 **서로 간섭**하여 동시에는 사용이 불가능했다. 

**현재** : **xDSL (Digital Subscriber Line)**

- 기존 전화선을 그대로 사용하지만, **주파수 대역을 나눠 (FDM)** 음성과 데이터를 **동시에 전송**하는 기술
- xDSL의 종류
  - **ADSL (Asymmetric DSL)** : 다운로드 비대칭 (사용자 down이 더 많다.)
  - **VDSL (Very high-speed DSL)** : 고주파수 사용, 근거리용 

**Cable Modem** 

- **TV용 케이블**를 이용한 데이터 전송
- Asymmetric: 다운로드 중심
- 단점 : **Shared Bandwidth** (같은 지역 사용자가 많으면 속도가 저하)



> **DSL의 실제 구조**

**구성 요소**

- **DSL Modem** : 사용자 PC와 전화선을 연결하는 장치
- **Splitter** : 전화와 데이터 주파수를 분리 
- **Central Office** : 전화국 (통신사 중심국)
- **DSLAM (DSL Access Multiplexer)**  : 여러 사용자의 DSL 신호를 모아 ISP 백본망으로 전달 



**ISP 가입자 선로의 발전 추세**

1. **전화선 공유 (FDM)** 에서 **전용 디지털 회선 (Dedicated Digital Link)** 
   - 전화와 분리된 **순수 인터넷 전용선**
2. **광 케이블** 보급 확대 
   - 구리선보다 감쇠가 적고, 장거리/고속에 유리 
   - **FTTH (Fiber To The Home)** : 집 앞까지 광케이블 연결
   - **FTTB (Fiber To The Building)** : 건물까지 광케이블, 이후 UTP로 분배



#### 무선 링크

> 앞선 유선 DSL, 광케이블과는 다른 개념 

**장점**

- **고정된 물리적 링크가 필요가 없다.** (설치와 이동에 용이하다)
- **이동성 (mobility)**이 지원
- **즉시 연결 가능** : 따로 케이블이 불필요하다. 

**단점**

- **공중으로 신호가 퍼진다.** (간섭될 수 있다.)
- **주파수 (고주파 VS 저주파) 특성**
  - 고주파 : 대역폭이 크고, 거리가 작다
  - 저주파 : 거리가 멀리 이동이 가능하지만, 속도가 낮다.
- **전파 간섭 및 라이선스 규제 필요**
  - 특히 고주파는 국가별로 사용 허가가 필요
- **Multipath Problem (다중 경로 문제)**
  - 신호가 벽, 물체 등에서 반사되어 **여러 경로로 수신**
  - 서로 간섭되고, 중첩되어 품질 저하가 발생
  - Wi-Fi, LTE 모두 이 문제 보정 기술을 사용 (예 : OFDM)



**이동통신 (Celluar Networks)**

- **기지국 (Base Station)과 단말기와의 연결**
- 하나의 기지국이 담당하는 지역 : **셀(Cell)**
  - 여러 셀들이 연결되어 **Celluar Network를 형성**

> **Handoff (핸드오프) 문제**
>
> - 사용자가 **이동하면서** 한 기지국의 범위를 벗어나면, 자동으로 **다음 셀**로 통신이 전환되어야 한다. 
> - 통화나 데이터 전송이 끊기지 않도록 하는 기술로, 이동통신 품질의 핵심 요소이다. 



**고정 무선통신 (Wireless Fixed Links)**

- **지점 간 (Point-to-Point)** 고속 무선 전송 링크
- **광케이블 매설이 어려운 지역**에서 대체용으로 사용 
- 종류
  - **무선 고속 전용 링크** : 직선(지향성) 통신 : 송신기와 수신기 직접 가시선이 필요하다. 
  - **무선 가입자망** : 광케이블 없는 지역에 기지국-가정 간 직접 연결 



**위성통신 (Satellite system)**

- 분류 (궤도 고도 기준)

| **종류**           | **고도**         | **예시**          | **특징**                                 |
| ------------------ | ---------------- | ----------------- | ---------------------------------------- |
| **정지궤도 (GEO)** | 약 36,000 km     | 방송·통신위성     | 지구 자전속도 동일 → 항상 같은 위치 관측 |
| **중궤도 (MEO)**   | 10,000~20,000 km | GPS 위성          | 넓은 범위, 중간 지연                     |
| **저궤도 (LEO)**   | 500~1,000 km     | Starlink, Iridium | 지연 적음(수십 ms), 위성 다수 필요       |

- 특징
  - GEO : **항상 고정 위치**에서 송수신이 가능하다. (방송과 위성전화에 활용)
  - LEO : **지연이 적고, 속도가 빠르다.** 하지만 위성의 개수가 수천 개가 필요하기에 운영비가 크다
  - 위성통신은 기본적으로 **단방향 또는 양방향 링크** 모두 다 가능



**단거리 무선통신**

- **Public (비면허) 주파수 대역** 사용
- **개인과 근거리 연결용**으로 가정, 사무실, IoT 환경에서 주로 사용 
- 주요 기술
  - Wi-Fi (IEEE 802.11) : LAN용, 고속
  - Bluetooth (IEEE 802.15.1) : PAN용, 저전력
  - ZigBee (IEEE 802.15.4) : 초저속, IoT 센서용 



### 인코딩

- **데이터 (Data)**는 컴퓨터 내부에서 **디지털(0/1)**로만 존재
- 따라서 이를 링크(구리선/공기/광섬유)로 보내기 위해서 **전달 가능한 신호(signal)**로 바꿔야 한다. 
- 이 변환을 넓게 **변조 (modulation)**이라고 부르고, 디지털 선로에서 파형을 정하는 건 **라인 인코딩 (line encoding)**이라고 한다. 
  - 수신 쪽에서는 반대로 **복조 (demodulation) / 디코딩 (decoding)**을 수행한다. 
- **일어나는 곳** : **NIC (네트워크 어댑터)** 안의 **signaling component**가 담당한다. 



#### 디지털 전송 : 아날로그 vs 디지털

**아날로그 전송 (과거 중심)**

- 선로에서 **신호(파형) 자체를 증폭**해서 보낸다. 
  - **Amplifier (앰프)**를 사용
- 문제 : 신호 + 잡음(noise) 가 함께 증폭되며 왜곡을 누적한다. 

**디지털 전송 (현재 표준)**

- 중간 장치가 **신호에서 '데이터(비트)'를 복원**하고, **깨끗한 새 신호로 재생성**해서 다음 구간으로 전송한다. 
  - **Repeater (재생 중계기)**를 사용
- 효과 : 누적 잡음을 제거하고, 장거리/고속에 유리, 부가기능 (오류 검출 등)을 쉽게 추가할 수 있다. 
- (아날로그 데이터는 먼저 **A/D 변환  후** 디지털로 싣는 게 일반적이다.)

**중요한 부분**

- 우리가 다루는 데이터는 기본적으로 **디지털 형태**
  - 단 **음성/음악**처럼 아날로그인 데이터도 물론 많다.
- 따라서 전송 전에 반드시 **아날로그 to 디지털 (A/D)** 변환 과정이 필요하다.
- 전송 중엔 **아날로그 신호 또는 디지털 신호**로 변조되어 전파된다.
- 수신 후에는 다시 **디지털 to 아날로그 (D/A)** 복원으로 인간이 들을 수 있게 변환한다. 

| **구분**         | **역할**                             | **예시**           |
| ---------------- | ------------------------------------ | ------------------ |
| **Data**         | 실제 정보 내용 (텍스트, 음성 등)     | Text, Voice        |
| **Signal**       | 물리 매체로 보낼 수 있게 변환된 파형 | 전압, 전류, 전자파 |
| **Transmission** | 네트워크상 전송 과정                 | 케이블, 무선 전송  |



#### PCM (Pulse Code Modulation)

**정의** : **아날로그 신호(연속값)를 디지털 비트(이산값)**으로 바꾸는 과정으로 전화, 오디오, 음성 통신 등에서 표준적으로 사용된다. 

**과정**

- **PAM Sampling (표본화)**
  - 연속적인 아날로그 신호를 **주기적으로 샘플링**한다.
  - 즉, 신호의 값을 일정한 시간 간겨으로 찍어서 **Pulse**를 만든다.
  - 이때 얼마나 자주 샘플링하는지에 따라 **품질**을 결정한다. 
- **Quantization (양자화)**
  - 찍은 샘플 값들을 **가장 가까운 이산적인 숫자 (레벨)**로 반올림한다.
  - 실제 값과 근사값의 차이 : **양자화 오차 (Quantization Error)**
- **Encoding (부호화)**
  - 양자화된 각 레벨을 **이진수 (bit)**로 표현한다. (디지털 데이터로 전환)



> 음성 데이터의 디지털화 예시

**Sampling Theorem**

- 샘플링 주파수는 신호의 최고 주파수보다 **2배 이상**이어야 원 신호 복원이 가능하다. 
  - 이유 : 너무 낮게 샘플링하면 aliasing (겹침) 가 발생하여 신호를 왜곡한다.



#### 변조 (Modulation)

**1. Amplitude Modulation (AM)**

- 반송파의 진폭을 바꿔 비트를 실어서 보낸다. 
  - 1비트 전송 예시 : 1이면 진폭이 높고, 0이면 진폭이 낮게 (혹은 꺼짐)
- 레벨을 확장하면 한 심볼에 2비트로 `00, 01, 10, 11`이 가능

> **QAM (Auadrature amplitude Modulation)**
>
> - **AM + PM**을 동시에 바꿔서 심볼 수를 대폭 늘린다. 



**2. Frequency Modulation (FM)**

- **FM/FSK** : 반송파의 **주파수**를 바꿔서 정보를 전달한다. 
  - Binary FSK : `f0 = 0, f1 = 1`
  - M-FSK : `{f1, f2, f3, f4}`로 2비트 /심볼 등
- 장점 : 진폭 잡음에 강하다. (라디오의 FM이 깨끗한 이유)
- 단점 : 대역폭 소모가 커질 수 있기에 구현이 비교적 복잡하다. 



**3. Phase Modulation (PM)**

- **PM/PSK** : 반송파의 **위상**을 특정 각도로 바꿔서 정보를 전달한다. 
  - BPSK : 0에서 180도 
  - QPSK : 0 / 90 / 180 / 270 도로 (2비트/심볼)
- **잡음 내성** : 위상은 진폭 변동에 비교적 강하다. 



**속도 (용량)를 올리는 세 가지 방법**

- **모듈레이션 기법 향상**
  - BPSK -> QPSK -> 16-QAM -> ... 
  - **같은 심볼율 비트율이 올라간다**. + 단, 오차 여유(점 간 거리) 감소 -> **SNR 요구가 높아진다.**
- **고주파 (넓은 대역폭)을 사용한다.**
  - 더 높은 주파수 영역을 쓰면 **사용 가능한 대역폭(Hz)**이 커진다. (최고 전송속도가 올라간다.)
  - 단, 고주파일수록 **감쇠가 크고, 도달거리가 낮아지고, 차폐에 취약**하다. 
- **병렬 전송 (다중화)**
  - **주파수 분할 (OFDM, WDM), 공간 다중 (MIMO), 채널 분할** 등으로 "여러 갈래"를 동시에 사용한다. 
  - 한 채널의 품질이 나빠도 나머지로 보완이 되기 때문에 **실효 처리율이 높아진다.**



> 아날로그 데이터에서 아날로그 신호로도 변환이 가능할까?

- 아날로그 데이터 : 사람의 음성, 음악처럼 연속적인 파형
- 아날로그 신호 : 전파 형태로 바꿔 송신할 수 있는 반송파 

**과정 요약**

1. Sound -> Electrical analog (마이크 출력)
2. PCM Encoding : 샘플링 + 양자화 + 부호화
3. 디지털 변조 : 비트를 주파수와 위상 등으로 바꿔서 신호화
4. 전송 : 리피터를 사용이 가능 (S -> D -> S)



**전송형태 구분**

| **구분** | **데이터 형태** | **신호 형태** | **예시**              |
| -------- | --------------- | ------------- | --------------------- |
| **A→A**  | 아날로그 데이터 | 아날로그 신호 | AM/FM 라디오          |
| **A→D**  | 아날로그 데이터 | 디지털 신호   | PCM 음성 통신         |
| **D→A**  | 디지털 데이터   | 아날로그 신호 | 모뎀 (인터넷 접속 등) |
| **D→D**  | 디지털 데이터   | 디지털 신호   | 이더넷, 광통신 등     |



#### 인코딩 (Encoding)

- 디지털 데이터를 **디지털 신호**로 변환, 주로 **유선 링크**에서 사용한다. 



**1. NRZ (Non-Return to Zero)**

- 가장 기본적인 디지털 신호 표현 방식 
- 1 -> High 전압 (+5V) , 0 -> Low 전압 (0V)
  - 전압이 0으로 복귀하지 않기 때문에 NRZ라고 부른다. 

- 장점 : 단순하고 하드웨어 구현하기가 쉽다.
- 단점 : **연속된 1 또는 0**으로 신호의 변화가 없어서 수신기 동기화가 불가능하다. 
- 문제점 : **Clock 복구 불가능**
  - 수신 측은 송신 측의 **클록 주기 (bit 폭)**을 알고 있어야 정확히 0/1 판별이 가능하다.
  - 하지만 신호 변화가 없으면 '비트가 몇 개인지' 기준을 잃게 된다. 
  - 이는 **동기화 오류 (Synchronization Error)**를 발생한다. 

> 문제 발생 예시
>
> 상황 : 송신자와 수신자가 같은 속도로 시계(Clock)를 돌린다고 가정 
>
> - 하지만 실제로는 항상 미세한 오차가 발생한다. **(수신자의 Clock이 더 빠르거나 느리다.)**
>
> 문제 : 송신은 00101 .. NRZ 파형을 전송
>
> - 수신 : 빠른 Clock으로 비트 경계를 조금씩 앞당긴다. 
> - 이것이 누적되면 비트 폭이 달라져서, 한 비트를 두 번 읽거나, 건너뛰게 되는 오류가 발생한다. 

- 해결 방법
  - **클록을 같이 송신에서 보내는 방식**이 필요함.
    - 이후의 **Manchester, Differential Manchester**과 같은 인코딩 방식이 등장



**2. NRZI (Non-return to Zero Inverted)**

- 규칙 : **1이면 전이 (Transition), 0이면 상태 유지**
- 효과 
  - 1이 길게 반복될 때도 전이가 있기 때문에, **1이 연속될 때의 DC/동기 문제를 완화**
  - 반대로 **0이 길게 반복되면 전이가 사라지기 때문에** 수신기가 **클록을 복구하기 어렵다.**
    - (mid-transition이 부족)
- 간단하고 효율도 좋지만, **클록 복구 신뢰성 패턴에 따라 흔들린다.**



**3. Manchester**

- 규칙 : **비트 중앙 (mid)에서 항상 전이**가 생기도록 데이터를 클록과 XOR
  - 흔한 매핑 : 0 -> 상승, 1 -> 하강 (반대로 정의도 함)
- **매 비트 중앙에 전이가 있기 때문에 수신기가 클록을 자동 복구할 수 있다.**
- **비트 당 반드시 한 번 전이가 되야 하기 때문에, 대역폭이 2배가 필요하다.**



![NRZ](/../images/2025-10-12-Communication_02/NRZ.png)

**Mid-transition**

- 송신 : 
  $$
  M_i = Data_i ⊕ Clock_i
  $$

  - **데이터에 클록을 섞어서 보낸다.**

- 수신 : 수신한 M과 자신이 해석한 Data로 Clock을 역산한다. -> **클록을 복구**

- 특징

  - **전이 그 자체가 '시간 정보'** : 전이가 비트 중앙에 강제되기 때문에 **표본화 시점이 안정된다.**
  - 별도 clock을 쓰는 **out-of-band** 대신에, **데이터와 클록을 같은 선/대역으로 보내는 in-band 방식**

> **Manchester 코드는 Data에 Clock을 얹어서 같이 보내는 것**이다. 



**4. 4B/5B**

- 동기/DC 문제를 줄이면서 효율을 끌어올리는 **블록 코딩** 아이디어
- 규칙 
  - **4비트 데이터 -> 5비트 코드**로 매핑 (테이블 지정)
  - 5비트 코드는 '전이 부족'패턴을 금지 : 앞쪽에 최소 한 개의 1을 보장, 뒤쪽 0 연속도 최대 2개 등으로 제한
- 만든 5비트 스트림을 **NRZI**로 보낸다. 
  - 항상 전이가 생기기 때문에 **클록을 복구할 수 있다.**
- 효과 : 순수 Manchester 보다 효율이 높다. (약 80%)



### 프레이밍

- 링크 위로는 끝이 없는 비트 흐름이 흐르기 때문에 그대로 수신측이 **메시지의 경계**를 알 수 없다.
- 송신측이 비트들을 **작은 덩어리 (frame)**로 잘라서 보내고, 수신측이 그 경계를 인식할 수 있게 **표식/규칙**을 넣어준다. 
- 프레임에는 보통 : **헤더(주소, 제어) + 바디(데이터) + 트레일러(오류 검출 CRC 등)** 가 들어간다. 
- 실제 구현은 전통적으로 **네트워크 어댑터 (NIC)** 가 담당한다. 
  - 호스트 메모리에서 데이터 일부를 가져와 **캡슐화를 하여** 비트 스트림으로 내보낸다. 



**1. 바이트 중심 프로토콜 (Byte-Oriented Protocols)**

**아이디어** : **문자(바이트) 단위**로 프레임 경계를 표시. 

- **보초(Sentinel Approach)** 방법
  - 프레임 **앞/뒤에 특별한 바이트**를 둬서 경계를 표시한다.
  - 예) **BISYNC** : STX(시작), ETX(끝) 같은 **제어 문자 사용**
  - 문제 : **데이터 안에 그 바이트가 등장**한다면?
    - 해결 : **확장 (escaping)** - 앞에 **DLE(ESC)** 같은 **escape 문자**를 붙여서 데이터임을 표시

- **바이트 수 (Length)** 방법
  - 헤더에 **Count/Length 필드**로 **프레임의 길이**를 명시
  - 장점 : 명확하고 간단, 경계표식에 대한 충돌 이슈도 없다.
  - 단점 : **길이 값이 깨지면** 수신자가 **끝 위치를 잘못 잡아** 이후 프레임까지 **도미노 붕괴**가능, CRC가 뒤에 있어 **경계를 잘못 잡으면 검증 자체가 실패/무의미**해질 수 있다. 



**2. 비트 중심 프로토콜 (Bit-Oriented Protocols)**

**아이디어** : 프레임 경계를 **특정 비트 패턴**으로 표시하고, 데이터에 같은 패턴이 생기면 **비트 단위로 회피**

- **HDLC/PPP (동기 링크) 스타일**
  - **FLAG(경계) 비트열** : 01111110(0x7E)
  - **비트 스터핑 (bit stuffing)** 규칙:
    - 데이터 비트 중 '1'이 5개 연속 나오면, 그 다음에 '0'을 삽입한다. 
    - 이렇게 하면 데이터 내부에서는 경계가 **절대 만들어지지 않는다.**
  - 수신 측 처리:
    - 비트 스트림에서 **01111110**을 발견하면 **프레임의 시작/끝**임을 확인
    - 프레임 내부에서 '1' 5개 다음의 '0'을 보면 그 '0'은 **스터핑이므로 삭제**
      - 만약 다음 비트가 **1**이면 **경계를 의미, 프레임 종료**
    - 다음 비트도 1이면 **오류로 판단**
  - 장점 : 텍스트 뿐만 아니라 **임의의 비트열을 안전하게 전송할 수 있다.** (완전한 투명성)



### 오류검출

#### 오류 검출 코드 (Error Detecting Code : EDC)

- 본 데이터 뒤/앞에 **부가 데이터**를 덧붙여, 수신자가 오류 발생 여부를 판단하게 해 주는 코드
- 송신 측 : 
  - 데이터 D를 입력으로 함수 `f(D)`를 계산하여 **EDC 생성**
  - 전송 단위 : `[D|EDC]`
- 수신 측 :
  - 받은 데이터 D로 동일한 함수인 `f(D')`을 재계산하여 **EDC'**
  - 비교 `EDC' == 수신된 EDC ?`
    - 같으면 오류가 없음 (또는 미검출), 다르면 "오류 검출"
- 요구 조건
  - **공간 오버헤드가 작아야 한다.** (EDC길이는 D보다 훨씬 작게)
  - **계산이 빠르고 단순**해야 한다. (링크에서 실시간 처리)
  - **검출률(탐지 확률)이 높아야** 한다. 



**오류 검출율**

- **완벽한 검출**은 불가 : 어떤 EDC든 **미검출** 가능성이 0이 될 수는 없다.
- 시스템 신뢰성 관점에서, 미검출은 **데이터 무결성 (Integrity) 손상**으로 매우 위험 
  - 실무에서는 **검출률이 높은 코드**를 쓰고, **중복 검사**도 같이 병행함. 



#### 2차원 패리티 (Two-Dimensional Parity)

![Parity](/../images/2025-10-12-Communication_02/Parity.png)

**동작 원리**

- 데이터를 **행렬 형태**로 배열하고, 
  - **각 행마다 패리티 비트를** 붙인다.
  - **각 열마다 패리티 비트를 하나 더 붙인다.**
- 수신 시 행/열 패리티를 모두 확인:
  - **단일 비트 오류** : 한 행 패리티와 한 열 패리티가 동시에 틀림 
    - **교차점이 오류 위치** : 위치 파악 + 수정이 가능함. (1비트 정정)
  - **다중 오류** : 많은 경우 검출 가능하지만, 특정 패턴 (짝수개가 같은 행.열에 균형)에서는 **미검출 가능**

**장단점**

- 장점: 단일 비트 오류는 **검출 + 정정**이 가능. 간단하고 하드웨어 구현이 쉽다. 
- 단점 : 오버헤드가 **행 수 + 열 수**만큼 늘고, **긴 버스트 오류**에 대한 보장은 CRC 보다 약하다. 



#### 인터넷 체크섬 (Internet Checksum Algorithm)

**사용 하는 곳** : IP, TCP, UDP 헤더 검증

**아이디어**

- 메시지를 16비트 단위 (2바이트씩)로 나눔
- 16비트를 단위들을 **1의 보수 덧셈**으로 모두 더함.
  - 1의 보수 덧셈 : 합이 16비트를 초과하면 넘친 캐시를 **다시 더함**
- 최종 합의 **1의 보수(~)**를 취함. -> 이것이 **체크섬 (EDC)**

- 수신 측 :
  - 수신한 데이터 + 체크섬을 **같은 방식으로 모두 더했을 때 결과가 `0xFFFF`**이면 "오류 X", 아니라면 오류로 간주 

**특징**

- 연산이 단순 (CPU 명령 몇 개로 가능 -> 헤더 검증에 적합)
- **공간 오버헤드 = 16bit**, CRC 보다 작다. 
- 단점 : 
  - 덧셈 기반이라 **비트 순서나 짝수개 오류에 약하다.**
  - 검출률이 CRC보다는 떨어진다. 



#### 순회 중복 검사 (Cyclic Redundancy Check : CRC)

**아이디어**

- 수학적 원리 : **나눗셈** 기반 오류 검출
- 송신자와 수신자가 **약속된 생성 다항식 (제수, C)**를 공유 
- 데이터 (M)에 EDC(F)를 추가하여, 전체 프레임이 **C로 나누어 떨어지도록** 한다. 
  - 즉, `(M || F) % C = 0`
- 수신 측은 받은 프레임을 다시 C로 나누어 **나머지가 0이면 정상**, 아니면 오류 검출



**송신 측 절차**

1. M에 **0을 (C의 차수 - 1)개**를 붙여서 임시 프레임을 생성한다. 
2. 그걸 **C로 나눈 나머지 = F** 를 계산한다. 
3. F를 원래 데이터 뒤에 붙여서 전송한다. 
   - 전송 프레임 = `[M | F]`

예시)

~~~bash
M = 1101,  C = 1011
→ M에 3개의 0 붙이기: 1101000
→ 나눗셈(XOR 기반) 수행, 나머지 F=101
→ 전송: 1101101
~~~

(송신자 세부 사항)

- CRC는 **비트열 -> 다항식 (polynomial)**으로 표현해서 처리한다.
  - 각 비트는 **다항식의 계수 (0 또는 1) 로 대응된다. 

~~~bash
예: 메시지 10011010 → M(x) = x⁷ + x⁴ + x³ + x¹
~~~

- 제수 `C(x)`도 동일하게 다항식으로 표현

~~~
예: C(x) = 1101 → x³ + x² + 1
~~~

**계산 절차**

1. `M(x) 에 X^^k를 곱함` ( k = 제수 차수) -> F 자리 확보

2. 그 값을 C(x)로 나눔 -> 나머지 P(x)

3. 전송 프레임 
   $$
   M(x)·xᵏ + P(x)
   $$
   

> **(M‖F)가 C로 나누어떨어지게 하는 F를 만든다**

![CRC](/../images/2025-10-12-Communication_02/CRC.jpeg)



**수신 측 절차**

- 전체 프레임을 C로 나누기
  - 나머지 = 0 : 오류가 없다.
  - 나머지 != 0 : 오류가 있다. (검출되었다.)



> **중요 포인트**
>
> - C (제수)의 자리수 - 1 만큼 EDC (나머지) 길이가 정해진다.
> - CRC의 **검출률은 C 다항식의 설계에 달려 있다.**



**성능**

- CRC의 검출 성능은 **C (다항식)**의 선택에 따라 좌우된다. 
- 좋은 다항식을 사용하면 검출률이 매우 높다.
  - 1500 Byte 이상의 데이터에 대해서 99.99...%의 검출

- **연산 속도**
  - CRC 연산은 CPU가 아닌 **NIC 하드웨어**에서 XOR 기반으로 수행 
    - 속도 느림이 없이 전송이 가능하다. 
  - **다항식 연산**이기에 단순하고 빠르다. 



**CRC 코드 (표준 다항식)**

| **CRC 이름** | **다항식 C(x)**                     | **비트 수** |
| ------------ | ----------------------------------- | ----------- |
| CRC-8        | x⁸ + x² + x + 1                     | 8bit        |
| CRC-10       | x¹⁰ + x⁹ + x⁵ + x⁴ + x + 1          | 10bit       |
| CRC-12       | x¹² + x¹¹ + x³ + x² + 1             | 12bit       |
| CRC-16       | x¹⁶ + x¹⁵ + x² + 1                  | 16bit       |
| CRC-CCITT    | x¹⁶ + x¹² + x⁵ + 1                  | 16bit       |
| CRC-32       | x³² + x²⁶ + x²³ + x²² + x¹⁶ + … + 1 | 32bit       |



> (참고) CRC의 하드웨어 구현 

- **XOR Gate + Shift Register** 기반 회로로 동작
- 제수 `C(x)`에 따라 XOR 게이트의 위치가 달라진다. 
- 프레임 전송 중에 **동시에 CRC 계산을 수행**한다. 



---

## 신뢰성 있는 전송

> 오류 검출 이후에 **복구**를 하는 방법에 대한 소개 

- 데이터가 전송 중에 손상이 된다면 단순하게 검출하는 것만으로는 부족하다. **즉 복구가 필요하다.**
- 복구의 두 가지 방식
  - **FEC (Forward Error Correction)** : 송신 시 데이터에 **오류 수정 정보를 함께** 전송
  - **ARQ (Automatic Repeat Request)** : 오류 검출 이후 수신자가 **재전송 요청**



### 오류 수정 코드 (FEC)

**개념**

- **FEC = Forward Error Correction**
  - 송신자가 미리 **오류 수정용 비트 (ECC)**를 데이터와 함께 보낸다. 
  - 수신자는 재전송이 없이 자체적으로 오류를 수정할 수 있다. 
- 예시 : **2차원 패리티 (2D Parity)** (1비트 오류는 검출 + 수정이 가능)
- 수신 시 **행/열 교차점**에서 오류 위치를 찾아서 고친다. 

**특징**

- **재전송이 불가능하거나 비효율적인 환경에서 사용된다.**
  - 예 : 실시간 통화
  - 재전송으로 늦게 도착한 데이터는 의미가 없음. (지연 > 무의미)
- 정확도보다는 **지연 최소화**가 더 중요한 경우에 적합하다. 



### 재전송을 통한 오류 복구 (ARQ)

**개념**

- **ARQ = Automatic Repeat reQuest**
  - 수신자가 오류를 검출하면 송신자에게 **재전송 요청**을 자동으로 보낸다. 
- 동작 원리
  1. 송신자는 프레임 전송 후 `ACK` 대기
  2. 수신자가 `ACK`을 보내지 않거나 오류를 검출 시, 송신자는 **Timeout 이후 재전송**
  3. 정상 수신 시에만 다음 프레임을 전송
- 특징
  - 재전송에는 **시간/버퍼 관리**가 필요하다.
  - 따라서 어댑터 (NIC) 만으로는 처리가 불가능하여 **노드 내 소프트웨어**가 함께 담당한다.
  - 계층상 데이터링크 (2계층) 기능이지만, 실제로는 **호스트 내부에서 구현된다.**

![ARQ](/../images/2025-10-12-Communication_02/ARQ.jpeg)

**자세한 동작 과정 & 오류 처리** : ARQ 응답 (ACK) 및 타임아웃

ARQ는 **ACK(응답) 과 Timeout(시간 초과)**를 이용해 프레임 재전송을 자동으로 수행한다. 

> 여기서 송신자는 "상대방이 잘 받았는지" 직접 볼 수 없기 때문에
>
> **ACK 메시지를** 기다렸다가 일정 시간 내에 안 오면 **Timeout -> 재전송**한다. 

생길 수 있는 가능성들

- 정상 수신 / Frame 손실 / ACK 손실 / 둘 다 손실 
- **문제점** : ACK 손실 시에 **중복 프레임 전송**이 발생한다. 수신자가 이를 구분하지 못 하면 데이터 중복 처리의 위험이 있다. 



**해결 방법 : 순서번호 (Seq. #)**

- ACK 분실로 인해 생긴 중복 전송 문제를 해결하기 위한 장치
  - 모든 프레임에 **식별자 (번호)**를 붙인다. 
  - 수신자는 **이미 받은 프레인 번호**를 보고 중복 여부를 판단한다. 
  - ACK에도 순서번호를 붙여 송신자에게 "어디까지 받았는지"에 대해 알려준다. 
- **동작 예시**
  1. 송신 : Frame0 -> 수신 : ACK0
  2. 송신 : Frame1 -> 수신 : ACK1
  3. ACK 분실 -> 송신자는 Timeout으로 Frame1을 재전송
  4. 수신자는 "Frame1을 이미 받음" -> **discard (폐기) 이후** 다시 ACK1을 보낸다. 

> 여기서 **중복 프레임은 버리되, ACK는 반드시 다시 보내야 한다.**



**설계 원칙**

- **상대 상태를 예측하지 말고 원칙대로 진행**한다. 
  - 즉 ACK 를 기준으로 다음 단계로 넘어간다. 
- **Frame과 ACK의 `Seq #`일치 확인**이 중요하다. 
- **송신/수신 동작을 완전히 분리하여** 독립적으로 작동시켜 전송 효율이 올라간다.



**성능 분석**

ARQ의는 다음 **4단계 동작**으로 구성된다.

1. **Error detection** : 오류 검출
2. **Acknowledgment (ACK)** : 수신 확인 신호
3. **Retransmission after Timeout** : Timeout 이후 재전송
4. **Negative ACK (NAK)** : 오류 발생 시 명시적 재전송을 요청 (선택 사항)

용어 정의

t_frame : 프레임의 전송 시간 

t_prop : 전파 지연 시간 (송신과 수신의 거리 영향)

ACK / NACK : 상대 상태를 확인하는 신호 (ACK : 성공, NAK : 실패)



- **Stop-and-Wait ARQ : 링크 사용률 분석**

  - 가장 기본적인 ARQ 형태로 송신자는 **한 프레임을 보내고, ACK이 도착할 때까지 기다린 이후에 다음 프레임으로 전송**한다.

    > 한 번에 하나씩 전송 : 구조가 단순, **효율이 낮음**

  - 한 주기 (전송 ~ 응답 수신) : **t₍frame₎ + 2·t₍prop₎**

    - 실제 전송 시간 : t₍frame₎
    - 나머지 시간 : **대기 (idle) 시간**

  $$
  U = \frac{\text{전송 시간}}{\text{전체 주기}} = \frac{t_{frame}}{t_{frame} + 2t_{prop}}
  $$

  > 여기서 **U**는 링크 효율 **사용률**이다. 

  => 즉, **효율을 높이기 위해서 한 번에 보낼 데이터의 길이가 크고, 거리가 짧아야 한다.**

  - **지연 X 대역폭 관계**

    - **Stop-and-wait** 구조에서는 **링크가 놀고 있는 구간**이 많다.

      -> 이를 정량화 하기 위해 **BDP (Bandwidth X Delay Product)** 등장



**BDP (Bandwidth - Delay Product)**
$$
\text{BDP} = \text{Link Bandwidth} \times \text{Propagation Delay}
$$

- **한순간에 링크 위에 존재할 수 있는 데이터의 양**
- Stop-and-Wait에서는 BDP가 클수록, 지연이 크거나 링크가 빠를수록 **비효율이 증가한다.**



#### 정지 대기(Stop-and-Wait)

- 송신자는 **한 번에 하나의 Frame만 보내고**, 반드시 **ACK를 받은 뒤에만** 다음 프레임을 전송한다. 
- 송신 -> 대기 -> 송신 -> 대기.. 의 반복 구조
- 문제점
  - **파이프라인(링크)을 꽉 채우지 못한다.**
  - 링크 상에는 매 순간 하나의 프레임만 있기 때문에 BDP가 놀게 된다. 



#### 슬라이딩 윈도우 (Sliding Window)

- 송신자가 ACK를 기다리지 않고 **여러 개의 프레임을 연속 전송**하면, 파이프라인이 꽉 차게 된다. 
  - **링크 효율이 100%의 근접** 가능 
  - 효율적인 **오류 제어 + 흐름제어**가 가능함. 

**주요 용어 정리**

**Outstanding Frame** : ACK이 아직 오지 않은 전송 중인 프레임

**Window Size (N)** : 송신자가 한 번에 보낼 수 있는 프레임의 개수

**ACK #n** : "n번까지 잘 받았다. 다음은 n + 1을 보내라" 의미

**Stop-and-Wait = Window Size 1** : 슬라이딩 윈도우의 특수한 형태 



**성능**
$$
U \propto N, \quad \frac{1}{t_{prop}}, \quad t_{frame}
$$

- N이 클수록 (동시에 전송 가능한 프레임의 수가 크다)
- 전파지연이 작을수록
- 프레임의 크기가 클수록 효율이 증가한다. 

$$
N \times t_{frame} \geq t_{frame} + 2t_{prop}
\Rightarrow N \geq 1 + 2\frac{t_{prop}}{t_{frame}}
$$

​	- 다음의 조건에서는 송신자는 ACK 대기 없이 **연속 전송이 가능하다.**

> **시간 진행 표시법 및 해석**
>
> - **단일선 표시** :  전송 순서 위주로 시간 관계를 단순히 표시
> - **기울기선 표현** : 실제 시간 지연을 반영한 성능 분석용



**Sliding Window 의미 : 오류 없는 경우**

- 슬라이딩 윈도우는 단순히 **buffer**가 아니라 **현재 보낼 수 있는 프레임의 범위**를 나타낸다. 

  - 윈도우 크기 = 한 번에 outstanding(미확인) 상태로 유지 가능한 프레임 수
  - 송신자 : 아직 ACK를 받지 않은 프레임 범위
  - 수신자 : 받을 준비가 되어있는 프레임 범위 

  > ACK는 **누적 (cumulative)**으로 전송이 가능하다. 
  >
  > **중요** : **버퍼 (buffer)와 window**는 다른 개념
  >
  > - 버퍼 = 저장공간
  > - 윈도우 = **전송 허용 범위**



**오류가 있는 경우**

- 여러 개의 outstanding frame 중 어느 한 곳에서도 오류가 발생할 수 있다. 
- 두 가지의 오류 처리 정책이 존재
  - **Go-Back-N** : 오류가 발생한 **지점 이후 모든 프레임**을 다시 보낸다.
    - 구현은 간단하지만 효율이 낮다
  - **Selective Repeat (SR)** : 오류가 난 **프레임만 전송**한다. 
    - 효율이 높지만, 구현이 복잡하다. 



##### Selective Repeat 

- 각 프레임이 **독립적인 ACK / Timer**를 가진다. 
  - 모든 프레임을 개별적으로 추적하고 필요한 것만 재전송한다. 
- 동작 과정
  1. Sender : ptk0, pkt1, pkt2, pkt3 전송
  2. Receiver : pkt2 손실 -> 그 뒤에는 정상 수신 **(out-of-order 상태)**
  3. 송신자 : pkt2 timeout -> pkt2만 재전송
  4. Receiver : pkt2 수신 -> 순서대로 사우이 계층 전달 -> ACK2 전송

- 필요 조건
  - **Out-of-order 수신이 가능해야 한다.** -> 수신 버퍼가 필요하다.
  - **개별 ACK(Selective ACK)** : 각 프레임마다 "정확히 받은 상태"라는 것을 전달해야 한다.
  - 수신자는 **정확한 수신 상태 정보를** 송신자에게 알려야 한다. 



##### Go-Back-N

- 오류 발생 시, **그 지점부터 다시 전송 (Go-Back)**하는 구조
  - 송신자는 오류가 감지되면 **해당 프레임 이후 모든 Outstanding frame 재전송**
  - ACK는 **누적**방식으로 작동

**구현에서의 옵션 사항**

**수신 1** : out-of-order frame을 저장할 것인가?

- 폐기해도 되고 저장해도 된다. (둘 다 가능)

**수신 2** : ACK 전송 정책 

- no ACK 또는 duplicate Ack (누적 ACK 규칙 유지 )

**송신** : 재전송 시점

- 모든 Outstanding 한 번에 or 각자 timeout 기반

> - 구현의 연동 관계
>
>   - 수신자 동작에 따라서 구현의 차이가 발생
>   - (저장 유무 + Ack 정책 결합으로 4가지의 경우가 발생 가능)
>
>   - **송신자는 항상 outstanding frame + timer 관리 기본 동작을 유지**해야 한다. 

**버퍼링 요건**

| **구분**      | **필요성**                                                |
| ------------- | --------------------------------------------------------- |
| **송신 버퍼** | 필수 — 재전송 위해 보관                                   |
| **수신 버퍼** | SR : 필수 (out-of-order 저장) / GBN : 선택 (성능 향상 용) |

-> 수신자가 버퍼를 쓴다고 SR이 되는건 아니다. 

**Selective Repeat**은 **개별 ACK + 정확한 수신 정보**를 송신자에게 전달해야 한다.



#### 프로토콜 구현

- 에러제어는 처음으로 하드웨어가 아니라 **소프트웨어**로 구현되는 프로토콜
- 송신/수신은 **동시에, 독립적**으로 돌아가면서 이벤트에 반응하는 **동시성 프로그램**이라는 점이 관점
- 실제 구현 난이도는 연산 자체보다는 **이벤트 순서**를 정확히 정의하는데서 나온다

**Go-Back-N의 세부 알고리즘 구현**

> 송/수신쪽 모두 **독립적**으로 동작

송신자 쪽 동작

- 각 **outstanding frame**마다 재전송 버퍼에 저장, **타임아웃 설정**
- ACK 수신 시 해당 프레임의 타이머 해제, 버퍼 해제
- 타임아웃이면 그 지점부터 **재전송**

수신자 쪽

- **누적 ACK**만 보낸다. 
- Out-of-order 프레임은 **저장하지 않는다.** 



**Sliding Window** 세부 알고리즘

**송신자 1** : **프레임마다** 순서번호 부여. 송신자는 3개의 상태 변수를 유지한다.

- **SWS** : Send Window Size (창 크기)
- **LAR** : Last ACK Received (가장 최근에 인정된 프레임 번호)
- **LFS** : Last Frame Sent (가장 최근에 보낸 프레임 번호)

$$
LFS − LAR + 1 ≤ SWS
$$

**송신자 2 ** : 이벤트별 동작

1. **상위층 전송 요청** 수신 :
   - 창에 여유가 있으면 LFS++, 프레임 전송, 해당 프레임 **타이머 시작**
   - 여유가 없으면 **대기(wait)**
2. **ACK 수신** (누적 ACK, 값 = n)
   - LAR을 n으로 점프 ( 그 사이 프레임 모두 인정)
   - 해당 범위 타이머/버퍼 해제 -> 창 열리면 **추가 전송**
3. **타임 아웃** 
   - k부터 다시 전송 (k...LFS), 각 타이머 재설정
4. 버퍼에는 **SWS만큼** 프레임 유지(재전송 대비)



**수신자**

- **RWS** : Receive Window Size (수신 창)
- **LFA** : Last Frame Acceptable (수신 창의 오른쪽 끝 번호)
- **NFE** : Next Frame Expected (다음에 정상 도착해야할 번호)



**시나리오(간단 순서)**

1. 송신: F0, F1, F2 연속 발사.
2. 수신: F0 OK ⇒ **ACK1**(다음 기대는 1). F1 **손실**. F2 도착하지만 **NFE(1)**가 아니라서
   - **기본 Go-Back-N**: **discard**(저장 안 함), ACK1 반복 가능.
   - **변형(저장형)**: 버퍼에 보관, ACK1 전송.
3. 송신: F1 **타임아웃** ⇒ F1부터 재전송(F1, F2, …).
4. 수신: F1 정상 수용 ⇒ 연속 구간이 F0–F1이 되면서 **NFE=2**,
   - (저장형이면 버퍼의 F2를 곧바로 연결하여 전달하고) **ACK3**까지 올리기도.
5. 최종: 누적 ACK로 송신 LAR이 크게 점프, 창이 열려 다음 프레임 진행.



<!-- 기말 범위 시작 -->

#### 순서 번호 공간 (Sequence Number Space)

ARQ 오류제어에서는 

- 프레임을 보내고 ACK를 받고 필요하면 재전송을 한다. 
- **문제** : 헤더의 크기는 제한되어 있어서 순서번호도 제한된 범위에서만 사용이 가능하다. 
  - ex) 3-bit 순서번호 : 0~7까지만 반복해서 사용함 
- **해결** : 순서번호는 계속 증가하지 않고, **순환** 한다. 
- **순서 번호 공간은 현재 전송 중인 프레임의 개수보다 커야 한다.**
  - outstanding 프레임들은 서로 **모두 다른 SeqNum**을 가져야 수신자가 구분할 수 있기 때문이다. 



> 새로운 문제 : **재전송된 프레임과 새로운 프레임이 같은 번호**를 가질 수 있다.
>
> - 수신자가 구분을 못할 수도 있는데, 어떻게 구분할 것인가?
>   - **이전에 받았던 패킷의 재전송인지, 새로운 패킷인지** 

**새로운 문제 : `SWS <= 순서번호 공간 크기` 는 불충분하다.**

**새로운 해결책**:
$$
SWS < (순서번호 공간)의 1/2
$$


#### Sliding Window 구현

- **프레임 하나하나를 실제로 보내는 건 NIC (네트워크 인터페이스 카드)**
  - 링크 어댑터 / 드라이버 / 하드웨어 
- **Sliding Window는 그 바로 위에서 돌아가는 소프트웨어**



**1) 헤더 구조**

~~~c
typedef u_char SwpSeqno;

typedef struct {
    SwpSeqno SeqNum;  /* 이 패킷의 순서번호 */
    u_char   flags;   /* 최대 16bit까지의 플래그 (ACK, DATA 여부 등) */
} SWPHdr;
~~~

- `SwpSeqno` : 순서번호 타입 (1바이트)
- `SWPHdr` : 슬라이딩 윈도우 헤더
  - `SeqNum` : 이 프레임의 시퀀스 번호 
  - `flags` : 이 프레임이 ACK인지, DATA 인지 등 상태 표시 



**2) 송신자 상태 구조**

~~~c
typedef struct {
    SWPSeqno LAR;  /* last ACK received: 마지막으로 성공적으로 ACK 받은 SeqNum */
    SWPSeqno LFS;  /* last frame sent: 마지막으로 보낸 프레임 번호 */

    Semaphore sendWindowNotFull; /* 송신 윈도우가 꽉 찼는지 제어하는 세마포어 */

    SWPHdr   hdr;    /* 미리 만들어 둔 기본 헤더(템플릿) */

    struct txq_slot {
        Event timeout; /* 이 프레임에 대한 타임아웃 이벤트 */
        Msg   msg;     /* 재전송을 위해 보관해 둘 프레임 복사본 */
    } sendQ[SWS];      /* 송신 윈도우 크기만큼의 버퍼 */
} SwpStateSender;
~~~

- **LAR / LFS**
- sendQ[] : 각 시퀀스 번호에 대한 프레임 복사본, 타임아웃 이벤트를 저장하는 **Slot 배열**



**3) 수신자 상태 구조**

~~~c
/* receiver side state: */
SWPSeqno NFE;  /* next frame expected: 다음에 와야 할 SeqNum */

struct rxq_slot {
    int received; /* 해당 번호의 프레임을 이미 받았는지 표시 */
    Msg msg;      /* 데이터를 임시 저장 */
} recvQ[RWS];    /* 수신 윈도우 버퍼 (Receive Window Size) */
~~~



**4) 송신 1**

- 상위 계층에서 frame을 SWP에게 넘겨줄 때 호출되는 함수 

~~~c
static XkHandle
sendSWP(SwpState *state, Msg *frame)
{
    struct sendQ_slot *slot;
    hbuf[HLEN];

    /* 1. 송신 윈도우가 열릴 때까지 기다림 */
    semWait(&state->sendWindowNotFull);

    /* 2. 새 SeqNum 할당 (LFS 증가) */
    state->hdr.SeqNum = ++state->LFS;

    /* 3. 해당 시퀀스 번호에 대응하는 슬롯 선택 (원형 큐) */
    slot = &state->sendQ[state->hdr.SeqNum % SWS];

    /* 4. 헤더 필드를 hbuf에 저장 */
    store_swp_hdr(state->hdr, hbuf);

    /* 5. 메시지 앞에 헤더 붙이기 */
    msgAddHdr(frame, hbuf, HLEN);

    /* 6. 재전송을 위해 프레임 복사본을 sendQ에 저장 */
    msgSaveCopy(&slot->msg, frame);

    /* 7. 이 프레임에 대한 타임아웃 이벤트 예약 */
    slot->timeout = evSchedule(swpTimeout, slot, SWP_SEND_TIMEOUT);

    /* 8. 실제로 아래 계층(LINK)으로 전송 */
    return send(LINK, frame);
}
~~~



**5) 송신 2**

- 링크 계층에서 수신된 프레임을 SWP가 받았을 때 호출되는 함수 
- 이 함수 안에서 **ACK 처리 + 데이터 수신 처리 둘 다 한다.**

~~~c
static int
deliverSWP(SwpState *state, Msg *frame)
{
    hbuf = msgStripHdr(frame, HLEN);      // 1. 헤더 떼어내기
    load_swp_hdr(&hdr, hbuf);            // 2. 헤더 구조체로 읽기

    if (hdr.Flags & FLAG_ACK_VALID) {    // 3. ACK인가?
        /* received an acknowledgment ---- do SENDER-side */

        if (swpInWindow(hdr.AckNum, state->LAR+1, state->LFS)) {
            do {
                struct sendQ_slot *slot;

                // 4. LAR를 한 칸 앞으로 이동하며, 그 사이 프레임 정리
                slot = &state->sendQ[++state->LAR % SWS];

                // 5. 해당 프레임 타이머 취소
                evCancel(slot->timeout);

                // 6. 복사해 둔 메시지 파괴
                msgDestroy(&slot->msg);

                // 7. 윈도우가 한 칸 비었으니 세마포어 signal
                semSignal(&state->sendWindowNotFull);

            } while (state->LAR != hdr.AckNum); // 누적 ACK라서 LAR == AckNum까지 반복
        }
    }

    // 아래쪽 if (hdr.Flags & FLAG_HAS_DATA) { ... } 는
    // "이 프레임이 데이터도 포함하고 있는 경우" 처리 (수신자 측 로직) — 슬라이드 뒷부분.
}
~~~



---

## 이더넷 / FDDI

### 이더넷 (Ethernet)

- **LAN 의 대표 기술**
  - 빌딩 내부, 학교, 연구소 등 좁은 지역에서 쓰는 네트워크 
  - 빠르고 설치가 쉬워서 지금도 모든 LAN은 Ethernet 기반이다. 
- **CSMA/CD** (이더넷의 핵심 MAC 방식)
  - **carrier sense** : 전송 전에 이미 누가 전송 중인지 반송파 신호를 감지하여 idle 판단
  - **multiple Access** : 여러 노드가 하나의 공유 버스를 통해 **동시에 접근**할 수 있는 구조
  - **Collision Detection** : 여러 노드가 동시에 송신하면 **충돌** 발생, 이를 감지하여 재전송을 수행함. 



**버스 토폴로지**

#### Classicial Ethernet

- 현재는 거의 쓰지 않지만, **이더넷의 원리를 이해하는데** 매우 중요
- 최대 세그먼트 길이 : 500m
- 최소 2.5m 간격으로 트랜시버 탭을 설치해야 신호 반사 문제 감소 
- **여러 세그먼트를 리피터로 연결**
  - 신호를 단순하게 증폭하고 재생성하여 다음 케이블로 전달 
  - 두 노드 사이에 최대 리피터 개수 제한이 존재함. 
- **호스트최대 1024개**
- **Tree 구조**
  - 버스가 여러 번 갈라져서 결국 tree 형태로 확장됨
  - 하지만 전체 케이블 길이 + repeater규칙은 반드시 만족해야 함. 
- 10Base5라고도 부름 (10은 10Mbps, 5는 500m)



#### 10BaseT Network

- 10Base2 : 케이블 단선/문제 발생 시 전체 네트워크가 다운되기에 매우 불편했음.
- **10BaseT** : Twisted-Pair (UTP) 케이블 + **Star Topology**
  - 각 호스트는 Hub로 연결 
  - 물리적으로는 star, 논리적 신호 흐름은 여전히 **bus** 처럼 브로드 캐스트 됨. 



### Frame format

~~~bash
Preamble – Dest addr – Src addr – Type – Body – CRC
~~~

- Preamble : 수신측이 **클럭을 동기화하기 위한 신호**
- Dest addr : 목적지 **MAC 주소**로 48비트 유니캐스트 주소 or 브로드 캐스트/ 멀티 캐스트 주소가 온다. 

- Src addr : 송신 측의 **NIC의 MAC 주소**
- Type : 이 프레임 안에 들어있는 상위 프로토콜을 표시 
- Body : 실제 데이터 (46 byte ~ 최대 1500 byte)
- CRC : 프레임 전체에 대한 **에러 검출 코드**



**MAC 주소의 특수 형태**

- **브로드캐스트 주소**
  - 48bit가 모두 1이 주소 : `FF-FF-FF-FF-FF-FF`
  - 같은 LAN에 붙어 있는 모든 NIC가 수신
- **멀티캐스트 주소**
  - **첫 비트가 1인** MAC 주소
  - 특정 그룹에 가입한 NIC들만 수신한다. 



**프레임 수신**

: 어댑터는 모든 프레임을 수신해서 호스트로 보낸다. 

- NIC 가 하는 일
  - 물리 계층에서 올라오는 모든 비트 스트림을 프레임 단위로 재조립 
  - CRC를 다시 계산해 **에러 검사**
  - 그 다음 목적지 MAC 주소를 보고 OS/호스트에 넘길지 말지를 결정 



### 전송 알고리즘 (Transmitter Algorithm)

**MAC : 다중 매체접근제어**

- 이더넷은 한 개의 공유 매체를 여러 노드가 같이 쓰기 때문에 누가 언제 보낼지 정하는 **MAC 프로토콜**이 필요
- **경쟁방식** : 중앙에서 스케줄링해주는 제어 방식 / 예약 방식이 아니라 각 노드가 **분산된 알고리즘**으로 스스로 경쟁 



**CS : carrier sense**

- **반송파 감지** : 전송하기 전에 회선 상태를 먼저 듣는다. 
- 회선이 **idle 이면**:
  - 즉시 전송 시작 
  - 다만 연속해서 프레임을 보낼 땐 프레임 사이에 인터프레임 갭을 기다림
- 회선이 **busy 이면**:
  - idle 상태가 될 때까지 계속 감시하다가 바로 전송
  - 이런 방식을 **1-persistent CSMA**라고 함 



**CD : Collision Detection**

- 전송 중에도 계속 회선을 감시해서 충돌 여부를 확인하는 것 
- Why? 
  - 최악의 충돌 시나리오 : A와 B가 세그먼트 양 끝에 있고, **두 노드가 거의 동시에 전송 시작**
  - **10 Mbps 이더넷, 최대 전파 지연 → 51.2 µs** (슬라이드 값)
- **충돌 발생시**

1. 충돌을 감지한 노드들은 **jam signal**로 전송해서 다른 노드에게 멈춤을 알린다.
2. 해당 프레임 전송을 **중단**한다. 
3. 일정 시간 **지수적으로 커지는 backoff 후 재전송** 한다.



### FDDI

- 토큰링 **링 (topology)** 형태의 LAN 기술
- **IEEE 802.5 (16Mbps) + FDDI (100Mbps, 광섬유 기반)**

> **이더넷 = 경쟁 기반 (CSMA/CD)**
>
> **토큰링 = 제어 기반 (Token Control, collision  없음)**



**토큰링 MAC 기본 개념**

**1. 프레임은 한 방향으로만 흐른다.**

- 링 구조라서 패킷은 **모든 지국을 순차적으로 통과**
- Upstream -> downstream 방향



**2. 토큰 (Token)이라는 특별한 패턴이 링을 계속 돈다.**

- 데이터 전송 권한을 나타내는 작은 컨트롤 프레임
- 토큰이 있어야만 전송이 가능하여 **공평성 확보**



**3. 전송 흐름**

- 지국이 토큰을 받고, 전송할 데이터가 있으면 **토큰을 점유하고 데이터 전송 시작**
- 전송이 끝나고 난 이후 **토큰을 방출**
- 프레임이 다시 송신자에게 돌아오면 송신자를 제거 



> **동시에 토큰을 가진 노드가 존재할 수 없기 때문에 충돌이 발생할 수 없다.**



**FDDI 세부 특징**

1. 1-bit buffer, 모니터 지국 
2. **토큰 보유 시간 제한** : 토큰을 너무 오래 잡고 있는 **독점 문제 발생** (공평성 유지 위함)
3. **우선순위 전송 지원** : 예약 비트를 통해 높은 우선순위 traffic 전송 가능, 실시간 트래픽에서 중요한 개념 
4. 토큰 방출 방식
   - 즉시 방출 : 전송 끝나고 나서 바로 토큰을 내려놓음
   - 지연 방출 : 프레임이 한 바퀴 돌아올 때까지 토큰 유지 



---

## 무선 LAN

**IEEE 802.11 = Wi-Fi**

- 유선 LAN 에 대응하는 **무선 LAN 표준 802.11**
- 흔히 와이파이라고 부르는 것이 바로 802.11 기반 기술이다. 
- 세대별로 발전을 계속 함.
  - 802.11b ~ 현재는 802.11be : 
  - **세대가 바뀌어도 하위 호환 유지가 중요한 특징**
- **물리적 매체 : Spread Spectrum**
  - 802.11은 확산 스펙트럼 무선 라디오를 사용



### 802.11 LAN architecture

**Infrastructure Mode (보편적 Wi-Fi 구조)**

- 무선 단말은 반드시 **AP(Access Point, 기지국)**을 거쳐서 통신
- AP가 BSS의 중심
- 인터넷은 AP가 라우터/스위치와 연결되어 제공 



**Ad hoc Mode**

- AP 없이 **단말들끼리 직접 연결**
- P2P 형태의 임시 네트워크 
  - 예) 노트북끼리 직접 와이파이 연결, 임시 회의 공유 



**Wi-Fi Direct**

- 스마트폰과 프린터 같은 **1:1 직접 연결 기술**



> **확산 스펙트럼** (Spread Spectrum)
>
> - 802.11 은 **공용대역 (ISM band)**을 사용한다. 
> - 누구나 사용할 수 있는 대역이기에 서로의 신호 간섭/충돌을 피할수 없다. 
>   - 그래서 **일부로 신호를 넓은 대역에 spread**하여 보내는 방식 사용 
> - 핵심 원리
>   - 신호를 원래보다 **넓은 주파수 영역으로 확산**하여 전송
>   - 간섭은 일시적, 사용자별로 확산 방식이 달라서 동시에 사용이 가능 
>   - 포함되는 기술 **CDMA**



### 매체 접근 

- AP (Access Point) 하나에 A/B/C 단말이 매달려 있고, 이 무선 링크를 모두가 공유할 때
- **다른 무선기기와의 주파수 공유 문제**는 Spread Spectrum으로 해결이 가능하다. 
  - 여러 장치가 같은 대역을 쓰니까 서로 간섭이 가능하다. 
  - 확산 스펙트럼을 써서 **넓게 퍼뜨려서 간섭을 평균화 한다.**
- **같은 BSS 안에서의 채널 공유 문제는 여전히 남아있다.**
  - 같은 AP에 붙은 단말들은 사실상 같은 채널 하나를 공유
  - **누가 언제 보내냐는 스펙트럼으로 해결이 불가능**
    - **MAC (매체 접근 제어) 프로토콜이 필요**

- 이더넷과 비슷한 점
  - 이더넷처럼 **CS (Carrier Sense)**를 사용하여 보내기 전 채널이 비어있는지를 들을 수 있다. 
  - **CD가 무선에서 안되는 이유** : 너무 포화되어 있어 동시에 들어오는 약한 신호 구분이 어려움. + Hidden node 문제 



**Hidden Node**

- 무선 매체는 **거리 장애물, 감쇠의 영향을 크게 받음**
  - 수신지점이 B일때, 송신자  A/C 는 서로 모르는 상황에서 idle이라고 판단? (CS가 무의미하다.)

**Exposed Node**

- 노드: B, C가 서로 가까이; A는 B쪽, D는 C쪽에 있음.
- B → A, C → D 전송을 동시에 해도
  - 실제로는 **B 신호는 A쪽으로**, **C 신호는 D쪽으로** 가므로 간섭 거의 없음 ⇒ 동시에 전송해도 됨.
- 하지만 B와 C가 서로의 신호를 충분히 들을 수 있어 **동시에 보내도 되는데 괜히 멈추는 비효율** 문제 



### CSMA/CA

- C(Collision) A (Avoidance) : 충돌을 피하는 전략
- 기본 절차

1. 송신자가 수신자에게 **RTS (Request To send)** 전송
   - 너한테 데이터 보내도 되는지 알려주는 **짧은 제어 프레임**
2. 수신자가 송신자에게 **CTS (Clear To Send)** 전송 
   - 내가 받을동안 다른 사람들에게 조용히 하라고 전송
3. RTS를 보내고 CTS를 받은 노드만 실제 데이터 프레임 전송 



**송신자 입장**

- **CTS가 들리면 : 무조건 조용**
  - CTS안의 할당 정보 NAV 라는 정보를 포함해 **수신자 주변의 충돌을 방지**
- **RTS는 들리는데 CTS는 안들린다.** 
  - 자기 쪽 전송을 허용 : Exposed Node 문제 어느정도 해결 

![rts_cts](/../images/2025-10-12-Communication_02/rts_cts.jpeg)

**두 번째 상황**

- 두 개 이상의 노드가 **동시에 RTS**를 보내면 RTS 프레임끼리 부딪혀 충돌이 발생
  - CTS가 오지 않으면 충돌로 간주 
  - 이 후 **exponential backoff**를 적용해 다시 RTS 송신을 시도 



**RTS/CTS의 특징**

- 긴 데이터 프레임이 충돌나면 **손실 비용이 너무 크다.**
  - 따라서 RTS/CTS 로 짧은 프레임끼리 충돌나게 미리 필터링 
  - **긴 프레임 보호 효과**
- **비용 대비 효과적** : 충돌 확률이 높고, 프레임 길이가 긴 경우에 효과적인 상황  



### Mobility

**Case 1 : ad hoc networking**

- AP 없이 노드끼리 직접 연결 
- 이동성 지원은 네트워크 구조 자체가 단순해서 복잡하지 않다. 

**Case 2 : Access Point(AP) 기반 네트워크**

- 일반적으로 사용하는 Wi-Fi 구조 
- **고정 위치**이지만, 사용자는 움직일 수 있음. 
- 움직여서 현재  AP와 연결이 끊기면 다음 AP로 핸드오프 



**BSS 접속 / 가입**

**1) 스캐닝 (Scanning)** : AP를 찾는 과정

- 능동 스캐닝
  - 단말이 **Probe Frame**을 브로드 캐스트
  - 근처 모든 AP가 **Probe Response**로 응답
  - 단말이 이 응답들을 보고 어느 AP가 가장 좋은지 결정 
- 수동 스캐닝
  - 단말이 가만히 있다가 AP가 주기적으로 보내는 Beacond 프레임을 수신
  - 배더리 절약, 기본 탐색 방식 



**2) Association 과정**

1. 단말이 선택한 AP에게 **Association Request 전송**
2. AP가 **Association Response**로 허용
3. 새 AP가 DS를 통해 기존 AP에 붙었다는 것을 알려줌 (roaming 처리)



**3) Mobility 지원**

- 사용자가 움직이면 자동으로 더 좋은 AP로 접속 전환 (BSS transition)
- IP는 그대로 유지됨. (같은 DS 내에서는 당연히 유지됨) - Wi-Fi 내 이동성 



---

## 네트워크 어댑터

**네트워크 어댑터 (NIC) = 데이터 링크 기능이 구현되는 하드웨어**

세 가지의 기능이 반드시 들어있다. 

- **프레이밍**
  - Link 계층 프레임 생성과 해석
  - 헤더 붙이고 떼고, CRC 검증 등 수행
- **오류 검출 (Error detection)**
  - CRC32 등을 통해 **프레임 손상 여부 확인**
- **MAC (Media Access Control)**
  - CSMA/CD, CSMA/CA 등 실제 매체 접근 알고리즘을 수행
  - 언제 전송해야하는지를 결정하는 곳 



**CSR (Control Status Register)**

NIC는 **CSR이라는 레지스터 집합**을 갖고 있으며, CPU가 NIC를 제어할 때 CSR을 읽고 쓴다.

- **NIC 상태를 CPU가 읽음.**
  - 인터럽트 발생 여부
  - 초기화 완료 여부
  - 오류 발생 여부 등
- **CPU가 NIC에 명령을 전달**
  - 초기화, 전송 시작, 인터럽트 on/off 등 



### 호스트-어댑터 사이의 프레임 이동

**1. DMA (Directd Memory Access)**

- NIC가 **CPU 개입 없이** 메모리에 직접 접근하여 데이터 읽고/쓰기
- CPU는 주소만 세팅해주고 일은 NIC가 처리
- 고속이고 효율적이여서 high-spped NIC는 대부분 DMA를 사용한다. 

> Buffer Descriptor List : NIC가 어느 메모리 주소에 프레임을 넣어야 하는지/꺼내야 하는지 정의한 목록



**2. PIO (Programmed I/O)**

- CPU가 직접 NIC와 메모리 사이를 복사
  - CPU 오버헤드가 크고, 속도가 느리다
  - 단순하지만 비효율적 



**둘 중 무엇이 더 나은가?**

- 상황과 성능 요구에 따라 다르다.
- 현대 NIC는 거의 **DMA를 사용**하긴함. 

















