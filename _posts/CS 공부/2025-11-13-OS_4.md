---
layout: single
title: "Address space & Memory API"
categories: [OS]
tags: [운영체제]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"

---

이번 포스트는 OS의 **주소공간에 대한 개념과 Memory API**에 대해 다룬다. 



# Address Space

## Memory Virtualization

**Memory Virtualization (메모리 가상화) 이란?**

- 운영체제가 실제 메모리를 가상화하여 **각 프로세스에게 자신만의 독립된 메모리를 가진 것처럼 보이게 하는 기술**이다. 
- **OS가 물리 메모리를 잘개 쪼개서, 여러 프로세스가 동시에 메모리를 사용하는 것처럼 환상을 제공한다.**



> 왜 필요한가?

### 초기 메모리 시스템 (Without Virtualization)

예전에는 메모리 내에 **한 번에 하나의 프로세스만 로드가 가능하다.**

- 메모리 낭비가 심하고
- 멀티프로그램이 불가하고
- 성능이 낮음. 

=> **매우 비효율적인 구조**



### Multiprogramming and Time Sharing

**아이디어 : 하나의 메모리에 여러 프로세스를 올려 더 효율적으로 사용**

초기 OS : 한 번에 하나의 프로그램만

- CPU가 노는 시간이 너무 많아서 비효율적

`Load multiple processes in memory.`

- 메모리에 여러 프로세스를 동시에 올려주고 번갈아서 실행을 한다.
- 한 프로세스를 잠시 실행하고 중단한다.
- 정해진 타임 슬라이스마다 다른 프로세스로 교체를 한다.
  - **Time Sharing**
- 프로세스 A가 I/O를 기다릴때, 프로세스 B가 CPU를 사용하면 CPU가 놀지 않기 때문에, 전체 시스템의 효율이 증가한다. 

예시 그림) 

아래와 같이 구간을 나누어 **각 프로세스는 자신에게 배정된 공간 범위만 접근이 가능하다.**

~~~
[ OS           ]
[ Free         ]
[ Process C    ]
[ Process B    ]
[ Free         ]
[ Process A    ]
[ Free         ]
~~~



**문제 : Protection Issue**

- **다른 프로세스의 메모리에 잘 못 접근할 수 있다.**
  - 예시) 프로세스 A가 프로세스 B의 데이터를 덮어씌우는 상황



## Address Space (주소 공간)

**개념 : OS가 만드는 가짜의 개인 메모리 공간**

- 하나의 실제 물리 메모리를 여러 프로세스가 공유하면서도 **각 프로세스는 자기만의 독립된 메모리를 갖는 것처럼 보인다.**
  - **각 프로세스는 자기만의 독립된 메모리를 전체를 다 쓰는 것처럼 보이게 한다.**
  - 실제 물리 메모리와 1:1 대응이 아니라 **OS가 매핑**해서 연결해준다.

> C언어에서 주소를 출력하는 코드를 짤 때,
>
> 이때 나오는 주소가 가상주소 Address Space 의 값이다. 

**즉, 각 프로세스는 같은 가상의 주소 0KB를 사용하지만 (예시), 실제로는 다른 물리 주소에 매핑한다. 그리고 이 주소는 OS만 알고 있다.**



- 이 공간을 => **Address Space (주소 공간)** 이라고 함. 

~~~
0KB     Program Code
1KB     Heap
         (free space)
15KB    Stack
16KB
~~~

위와 같이 프로그램 실행 시 모든 데이터가 이 구조 안에 배치



**Address Space 구성 요소**

- **Code** : 프로그램의 기계어 (instruction)이 저장되는 영역
- **Data** : 전역 변수, static 변수
- **Heap** : 동적 메모리 (malloc / new로 증가하고, free / delete로 감소) 
- **Stack** : 함수 호출 스택 (지역 변수, return address 저장)
- (Free) : Heap, Stack 사이의 비어있는 공간으로 시간에 따라 공간을 확장

> **Stack과 Heap이 서로 반대 방향으로 향하는 이유**
>
> - 두 공간은 만나지 않고 서로 마주보며 커지도록 설계되어있다.
> - 그 이유는
>   - 유연하고
>   - 동적 크기로 증가가 가능하다. 
>   - (중간 Free 영역이 넓게 존재)



**왜 Address Space를 사용하는가?**

**1. 보호 (Protection)**

- 여러 프로세스가 동시에 메모리를 쓸 때 한 프로세스가 다른 프로세스 메모리를 맘대로 건드리면 안된다.
- OS는 프로세스마다 독립된 address space를 만들어 **서로의 메모리 간섭을 원천 봉쇄한다.**
  - 아까의 프로세스 A가 프로세스 B의 메모리를 건드리는 것과 같은 문제는 발생 X



**2. 편리함 (Convenience)**

- 모든 프로세스는 항상 **0KB ~ max** 사이의 동일한 구조를 가진다.
- 개발자가 물리 주소를 신경 쓸 필요가 없다.



**3. 효율성 (Efficiency)**

- 실제 물리 메모리는 여러 프로세스가 공유하지만, Address Space는 독립적이므로 **물리 메모리의 활용도를 최대로 끌어올릴 수 있다.**



# Memory API







