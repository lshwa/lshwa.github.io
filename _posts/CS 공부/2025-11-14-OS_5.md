---
layout: single
title: "Address translation & Segmentation"
categories: [OS]
tags: [운영체제]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"


---

이번 포스트는 OS의 **Address translation 과 Segmentation** 에 대해 다룬다. 



# Address translation

**Memory Virtualizing with Efficiency and Control**

- **메모리 가상화 (memory virtualization)**도 CPU 가상화(LDE)랑 **똑같은 목표**를 가진다. 
  - 여러 프로세스가 **각자 메모리를 전부 쓰는 것처럼 보이게** 만들기
  - 동시에 **효율(빨라야 한다.)** + 제어(안전해야한다.) 를 둘 다 만족해야 한다. 
- CPU 쪽에서 LDE (Limited Direct Execution)가 했던 것:
  - **효율** : 유저 프로그램을 진짜 CPU에서 직접 돌림 (가능한 한 빠르게)
  - **제어** : 시스템 콜 / 트랩 / 타이머 인터럽트로 **OS가 항상 최종 제어권**을 가진다. 
- 메모리 가상화도 마찬가지다.
  - 가능한 한 **직접 메모리에 접근하는 것처럼 빠르게** 만들어야 한다.
  - 동시에, **다른 프로세스 메모리에 함부로 못 쓰게** OS가 통제해야 한다. 

> 이걸 위해 **하드웨어 지원**이 꼭 필요하다.

(예시)

1. **레지스터** : 주소 변환에 필요한 기준 값을 저장
2. **TLB (Translation Look-Aside Buffer)** : 가상 -> 물리 주소 변화 결과를 캐시
3. **Page-table** : 전체 주소 변환 규칙을 저장해둔 테이블



## Address Translation

개념 : **가상 주소 (Virtual Address) -> 물리 주소 (Physical Address)** 변환 과정

- 프로세스 입장 : `0x400000` 같은 **가상 주소**만 본다. 
- 실제 RAM 안에서 데이터가 있는 위치는 **물리 주소**
- 하드웨어 (MMU)가 이 둘을 **실시간으로 매 접근마다 변환**해 준다. 

이런 변환이 필요한 이유?

1. **각 프로세스마다 독립적인 주소 공간 (illusion)**을 주기 위해 
   - 서로 같은 가상주소를 써도 **다른 물리 주소**로 매핑된다.
2. **보호 (Protection)**
   - 한 프로세스의 가상 주소가 **다른 프로세스 물리 메모리로는 매핑이 안 되게** 설정이 가능하다. 
3. **유연한 배치**
   - 프로그램을 물리 메모리 여기저기 흩뿌려두고, 가상 주소로는 연속인 것처럼 보이게 할 수 있다. 

**OS 의 역할**

- 하드웨어 혼자서 매핑 규칙을 만들 수가 없다.
  - 프로세스 생성 시, **페이지 테이블 / 세그먼트 테이블 같은 변환 규칙을 세팅**해야 한다.
  - 이 정보를 **하드웨어 (MMU)에게 알려준다.**
  - 페이지 교체, 프로세스 종료 등 상황 변화에 따라 **매핑을 갱신**한다. 

**실제 동작 과정**

~~~c
void func() {
    int x = 3000;
    ...
    x = x + 3;
}
~~~

`x = x + 3` : CPU는 다음 두 단계로 나누어 처리

- 메모리에 있는 변수 x 값을 **읽어서** 레리스터로 가져오고 (load)
- 3을 더한 뒤에, 다시 **메모리에 저장**한다. (store)



~~~assembly
128: movl 0x0(%ebx), %eax   ; 메모리(0+ebx) → eax
132: addl $0x03, %eax       ; eax = eax + 3
135: movl %eax, 0x0(%ebx)   ; eax → 메모리(0+ebx)
~~~

변수 x 의 메모리 주소가 **EBX 레지스터에 이미 저장돼 있다**고 가정

1. **Load** : `movl 0(%ebx), %eax`
   - EBX가 가리키는 주소의 값을 EAX로 가져옴
2. **Add** : `addl $3, %eax`
   - `EAX = EAX + 3`
3. **Store** : `movl %eax, 0(%ebx)`
   - EAX 값을 다시 EBX가 가리키는 메모리 주소에 저장 



### Example : Address Translation

**실제 6단계의 실행 순서**

1. **Instruction Fetch (주소 128)**
   - CPU는 PC 에서 128 이라는 가상주소를 읽고
   - 해당 위치의 명령어 `movl 0(%ebx), %eax`를 가져온다. (fetch)

2. **Execute**
   - EBX가 가리키는 주소 (=15KB)에서 값을 읽어 EAX로 옮긴다. 
   - 이 과정에서 **Address Translation**이 필요하다. 
   - Virtual Address -> Physical Address
3. **Fetch Instruction (주소 132)**
   - addl 명령어를 가져온다.
4. **Execute** 
   - 3을 더하는 명령어 실행
   - 이때는 메모리의 접근이 없다. 
5. **Fetch Instruction (주소 135)**
   - `movl %eax, 0(%ebx)` 명령어를 가져온다.
6. **Execute**
   - EAX의 값을 EBX가 가리키는 메모리(15KB)에 저장한다. 
   - 이때도 VA -> PA 의 변환을 거친다. 



## Dynamic Relocation

프로세스의 주소 공간 (Address Space)은 **항상 0KB부터 시작**한다고 가정한다. 하지만 실제 물리 메모리에서는 **절대 0KB에 둘 수가 없다.**

- 0KB ~ 일정 영역 = **OS가 차지하고 있기 때문**
- 여러 프로세스를 올리려면 메모리 다양한 위치에 올려야 한다. 

> 따라서 OS는 프로세스를 **물리 메모리의 아무 곳(어디든)**에서 실행을 시켜야 한다.  => **Dynamic Relocation (동적 재배치)**



### Base & Bounds (Limit) Register

Dynamic Relocation을 **하드웨어적으로 구현하는 방식**

**Base Register (베이스 레지스터)**

- 가상 주소공간의 **0KB가 물리 주소 어디에 위치하는가?**를 저장한다. 
- 프로세스의 **시작 위치**를 저장하는 레지스터

> **가상 주소 + base** = **Physcial Address**



**Bounds Register (Limit Register)**

- 프로세으의 주소 공간의 길이 

- 이 주소 이상 접근을 하려고 하면 메모리가 침범되기 때문에 OS가 차단을 한다. 

  - 이 과정은 **모든 메모리 참조마다 하드웨어가 반복**해준다.

  $$
  0 ≤ Virtual Address < Bounds
  $$

- 모든 가상 주소는 **0 이상, Bound (프로세스 크기)** 미만이어야 한다.



-> 앞선 예시 다시보기

~~~assembly
128 : movl 0x0(%ebx), %eax
~~~

128(가상 주소)에 위치한 명령어를 fetch하고 수행해야 하는데, 프로세스는 **물리 주소 32KB**에 위치해 있을때,

- **Fetch** 주소 변환

Virtual Instruction Address = 128

Base = 32KB (32768)

>  **Physical = Virtual + Base = 32896**

CPU는 **물리 주소 32896**에서 명령을 가져온다. 



- **Load** 주소 변환

~~~assembly
load from address 15KB
~~~

15KB = 가상주소

> **Physical = 15KB + 32KB = 47 KB**



**Bounds Register의 두 가지 해석**

**1. Bounds = Address Space Size**

- 주소 공간 크기를 그대로 저장
  - 가상 주소가 0~(bounds)~1 내에 있는지 체크
  - base는 따로 존재

$$
Virtual Address < Bounds
$$





**2. Bounds = Physical Address of End**

- 주소 공간의 **물리 끝 주소**를 저장

$$
(Virtual + Base) < Bounds
$$



## OS Issues

운영체제는 Base&Bounds 방식이 자동으로 굴러가게 하지 않는다.

**OS가 반드시 개입해야 할 4개의 시점이 존재**한다. 



### 1. When a Process Starts Running

- 프로세스를 메모리에 올릴 때 필요한 크기 만큼의 연속 공간을 찾아야 한다. 

**Free list**

- 물리 메모리에서 **사용 중이 아닌 연속 구간들의 목록**
- 각 노드에는 '얼마 만큼 비어 있는지'를 표시됨. 

**동작 과정**

1. OS는 free list를 확인한다. 
2. 새 프로세스가 예를 들어 16KB 가 필요하면
3. free list의 노드를 확인하고 알맞은 공간을 선택한다. 
4. 선택한 공간에 프로세스를 적재하고 base register에 그 물리주소를 넣는다. 



### 2. When a Process is Terminated

- 프로세스가 사라지면 사용하던 메모리 공간을 free list에 다시 추가하는 과정

**동작 과정**

1. Process A가 종료된다.
2. 그 프로세스가 차지하던 물리 메모리 공간을 OS가 확인한다.
3. Free list에 **다시 32KB free** (예시) 노드를 추가한다.
4. 그리고 Free list 정렬 / 병합 작업도 필요할 수도 있음.

> **정렬 병합 작업** : memory Fragmentation



### 3. When Context Switch Occurs

- Context Switch -> 단순히 레지스터 / PC만 바꾸는 것이 아니라 **메모리 보호 정보 (= base, bounds)**도 함께 바꿔야 한다. 

**Context Switch 과정**

1. CPU가 Process A의 base/bounds 값을 A의 PCB에 저장한다.
2. CPU가 Process B를 실행할 때
   - PCB에서 B의 base 값을 읽어와 Base Register에 넣는다.
   - PCB에서 B의 bounds 값을 읽어와 Bounds Register에 넣는다. 
3. 이제 CPU가 주소 변환을 할 때
   - `Virtual Address + Base(Register) = Physical Address`  를 올바르게 계산이 가능하다. 



---

# Segmentation

















