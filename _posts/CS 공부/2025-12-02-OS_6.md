---
layout: single
title: "FreeSpace Management & Paging"
categories: [OS]
tags: [운영체제]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"



---

이번 포스트는 OS의 **Free Sapce Management 와 Paging** 에 대해 다룬다. 



# FreeSpace Management

## Splitting

**요청된 메모리 크기보다 free chunk (빈 공간)** 가 더 클 때, 그 큰 free chunk를 **둘로 쪼개서** 하나는 할당하고, 나머지는 free list에 남기는 기법

- 목적
  - 너무 큰 free chunk 하나가 있을 때
  - 그 중 일부만 사용하고 나머지는 free list에 계속 남김
- **장점** : 메모리의 낭비 없이 효율적으로 사용이 가능하다. 
- **단점** : 조각난 free chunk가 많아지면 external fragmentation(외부 단편화)가 발생이 가능하다. 



**Splitting 예시**

- 전체 heap : 30bytes

- 구조

  ~~~
  0~10: free  
  10~20: used  
  20~30: free
  ~~~

- free chunk 2개

  - addr = 0, len = 10
  - addr = 20, len = 10

- **free list의 구조**

~~~
head → [addr:0, len:10] → [addr:20, len:10] → NULL
~~~



**작은 요청에 대한 Splitting 과정**

- free chunk 2개 (위와 같은 상황)
- 요청 (request) 크기 : **1byte**
- 과정
  1. free list 첫 번째 chunk(0~10)을 확인
  2. 요청 크기 = 1, free chunk 크기 = 10 -> **분할이 필요함**
  3. free chunk를 두 조각으로 나눔:
     - 1 byte - 할당
     - 9 byte - free chunk로 남김
- Heap 결과

~~~
free(0~1) → used(10~20) → free(21~30)
~~~

- Free list 변화

~~~
head → [addr:0, len:10] → [addr:21, len:9] → NULL
~~~



## Coalescing

- 반대로 사용자가 요청한 메모리 크기보다 free chunk가 작으면 할당이 불가능하다.
- **Coalescing (병합)** : 반환된 free chunk가 기존 free chunk들과 **주소상 인접해 있으면 하나의 큰 chunk로 합친다.**
  - free chunk가 여러 개로 잘게 쪼개져 있으면 큰 요청을 처리하지 못함. (외부 단편화 문제)
  - **붙어 있는 free chunk들을 합치면 큰 free chunk가 만들어져 큰 요청을 처리가 가능**하다. 



**Coalescing 예시**

- free list에 3개의 chunk가 존재:
  - addr = 10, len : 10
  - addr = 0, len : 10
  - addr = 20, len : 10
- 결과적으로 **0~30 범위의 하나의 큰 free chunk (len : 30)**으로 병합이 가능하다. 



---

**Tracking The Size of Allocated Regions**

- `free (void * ptr)`은 **크기 (size)**를 인자로 받지 않는다.
- 그럼 free할 때 해당 메모리 블록의 크기를 알까?
  - **malloc은 사용자 요청한 공간 앞에 header를 붙여서 metadata를 저장함.**



## Header

**Header 가 하는 역할** 

- **size** : 이 블록이 갖는 데이터 영역의 크기
- `free(ptr)` 실행 시 ptr 바로 앞을 보면 header 가 있으므로 이 사이즈를 읽어 free list에 되돌릴 수 있다. 

- 예시
  - 사용자가 `malloc(20)`을 호출 -> 20 바이트 + header 크기 만큼 확보
  - ptr은 **데이터 영역을** 가리키고, Header는 그 바로 앞에 존재



size 외에도 하는 일들 

- **magic number** : 메모리 손상 여부를 체크한다.
- **extra pointers** : 빠른 free 작업을 위해 (예 : double linked list 구조)
  - 실제 malloc(N) 에서 확보하는 크기 = N + header 크기



**코드 구현**

~~~c
typedef struct __header_t {
    int size;
    int magic;
} header_t;
~~~

- `free(void *ptr)`을 실행할 때:

~~~c
header_t *hptr = (header_t *)ptr - 1;
~~~

- ptr바로 앞에 (-1) header 가 있으므로 위와 같이 접근할 수 있다. 



## Embedding A Free List

문제점

- 일반적인 프로그램은 free list에 노드를 추가하기 때문에 `malloc()`을 호출하지만,
- **메모리 할당기(malloc) 구현체**는 `malloc()`을 사용할 수가 없다. 
  - 자기 자신을 만들 때 자기 자신을 다시 이용할 수 없기 때문이다. 

**해결 방법**

- 메모리 할당기는 **자신만의 heap을 직접 초기화**하고, 
- 그 heap 공간 내부에 **첫 free list node**를 만들어 둔다.

-> **free list는 heap 안에 직접 저장되는 구조**다. 



**Free list의 Node 구조**

~~~c
typedef struct __node_t {
    int size;
    struct __node_t *next;
} node_t;
~~~

- 각 free chunk는 다음 정보를 가짐.
  - size : 이 free chunk의 크기
  - next : 다음 free chunk를 가리키는 포인터 



- Heap을 만들고 **첫 free list을 만드는 과정**

  ~~~c
  node_t *head = mmap(NULL, 4096, ...);
  head->size = 4096 - sizeof(node_t);
  head->next = NULL;
  ~~~

  - 4096 Byte를 할당받았다면:

| **내용**                  | **크기**       |
| ------------------------- | -------------- |
| free list header (node_t) | 8 bytes        |
| 남은 공간                 | **4088 bytes** |

첫 free chunk

- 시작 주소 : head
- free 공간 : **4088 bytes**
- next = NULL

Heap 전체가 **free 상태**가 된다. 



### Allocation

- **메모리를 요청받으면 어떻게 할까?**

할당기는 다음과 같은 역할을 한다

1. free list에서 **충분히 큰 chunk**를 찾는다.
2. 그 chunk를 두 개로 **split**
   - 첫 번째 : 요청된 크기 + 헤더
   - 두 번째 : leftover chunk
3. free list의 크기를 줄이거나, leftover chunk를 다시 free list에 삽입 



**예시 : 요청 `malloc(100)`**

- malloc은 100byte를 사용자에게 주지만, 
  - header의 포함 크기는 **108 bytes** 
- **할당 후 상태**
  - 첫 108 bytes를 할당
    - header (size = 100, magic = 1234567)
    - 뒤에 100 bytes를 사용자에게 제공
  - 나머지 공간은 새로운 free chunk
    - 크기 : 4088 - 108 = **3980 bytes**



### Free

`free (sptr)`을 호출할 때

**1) `free()`는 sptr에서 header의 위치를 찾는다.**

~~~c
header_t* hptr = (header_t*)sptr - 1;
~~~

- malloc은 payload 주소를 return 하기 때문
- header는 그 바로 "앞"에 있다. 



**2) free된 chunk를 free list의 "head"로 삽입**한다.

- free list는 **LIFO (스택)** 형태로 유지

~~~c
void* tmp = head;
head = (header_t *)sptr - 1;
head->next = tmp;
~~~

- 새로 freee된 chunk를 리스트 가장 앞으로 넣음.
- 기존 head는 2번째 노드로 이동

> 아직은 **coalescing 이 일어나지 않은 단계**
>
> - free space는 총 3864 bytes가 존재하지만, 
>   - 100 + 3764
> - 아직 free chunks는 **분리되어 있는 상태** 



















