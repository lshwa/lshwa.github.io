---
layout: single
title: "Translation Buffer, Advanced Page Table"
categories: [OS]
tags: [운영체제]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

이번 포스트는 OS의 **Tranlstaion Lookaside Buffer와 Advanced Page Tables** 에 대해 다룬다. 



# Translation Lookaside Buffer

## TLB

- **MMU (Memory Management Unit)**안에 있는 **고속 캐시**
- 목적 : **가장 자주 사용되는 VA -> PA (virtual -> physical)** 변환 정보를 빠르게 제공
  - **페이지 테이블 전체를 매번 메모리에 읽지 않도록** 하기 위한 **하드웨어 캐시** 역할 

- 구조

~~~bash
CPU → Logical Address 생성
      ↓
     MMU
        ↳ TLB Lookup
           ● Hit → 바로 Physical Address 반환
           ● Miss → Page Table 접근 후 변환을 찾고, TLB에 저장
      ↓
Physical Memory 접근
~~~

**우선 TLB에서 변환을 찾는다.**

- 있으면 (TLB Hit) : page table 접근 없이 즉시 물로 주소를 획득한다.

- 없으면 (TLB Miss) : MMU가 페이지 테이블을 메모리에서 읽어 PFN을 얻고, 그 결과를 TLB에 넣고 다시 instruction을 재실행 

> TLB는 **캐시의 캐시** 같은 역할 



**TLB 기본 알고리즘**

- **Virtual Page Number 추출**
  - 가상주소 상위 비트 구간을 VPN으로 사용
  - page table indexing 용도

~~~c
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
~~~



- **TLB Lookup**
  - TLB 내부에 VPN과 동일한 entry 가 있는지 검색

~~~c
(Success, TlbEntry) = TLB_Lookup(VPN)
~~~



- **TLB Hit 처리**
  - 보호 비트 (읽기/쓰기/실행)가 허용되면 정상 접근
  - PFN (page frame number)을 가져와 offset 과 합쳐 물리 주소 생성 

~~~c
if(Success){
    if(CanAccess(TlbEntry.ProtectBit)){
        offset = VirtualAddress & OFFSET_MASK;
        PhysAddr = (TlbEntry.PFN << SHIFT) | offset;
        AccessMemory(PhysAddr);
    }
    else RaiseException(PROTECTION_ERROR);
}
~~~



> 아래는 TLB Miss 처리 
>
> - 한 번은 반드시 **페이지 테이블 액세스**가 필요
> - 이후 같은 주소 접근 시 TLB Hit로 빠르게 처리 

- **TLB Table Entry 위치 계산**
  - Page Table Base Register (PTBR)는 page table의 시작 주소를 나타냄
  - VPN을 인덱스로 하여 PTE로 주소를 계산

~~~c
PTEAddr = PTBR + (VPN * sizeof(PTE))
~~~



- **Page Table Access**
  - Valid bit = 0 
  - VPN이 유효하지 않다. -> **Segmentation Fault**

~~~c
PTE = AccessMemory(PTEAddr)
if(PTE.Valid == False)
    RaiseException(SEGFAULT)
~~~



- **새로운 변환을 TLB에 삽입**
  - 방금 얻은 변환 (VPN -> PFN)을 TLB에 저장
  - **instruction 재실행** (이제 TLB Hit 발생)



## Locality

TLB가 잘 작동할 수 있는 이유 = **프로그램의 지역성 (Locality) 때문**

### Temporal Locality (시간 지역성)

- 최근에 접근한 페이지는 **곧 다시 접근할 확률이 높다.**
  - 예: 같은 변수 반복 참조, 반복문 내 변수 



### Spatial Locality (공간 지역성)

- 주소 x를 접근했다면, **근처 주소**도 곧 접근 가능성이 높다. 
  - 예 : 배열 순차 접근 a[i], a[i + 1]



---

## Who handles TLB Miss?

- TLB miss 발생하면 누가 처리하는지는 CPU 아키텍처에 따라 다르다. 

### CISC 

- Intel x86 (하드웨어-managed TLB)
- TLB miss 시 CPU 하드웨어가 **직접 page table walk 수행**
- CPU가 메모리에서 page table 찾아보고 PFN 가져와서 TLB 갱신

**과정**

1. TLB miss
2. 하드웨어가 page table에서 PTE를 읽음
3. TLB 업데이트
4. Instruction 재실행

> - OS 의 개입이 거의 없다. (성능이 높음)
> - CPU가 메모리에서 page table을 직접 찾아보고 PFN에서 가져와서 TLB를 갱신



### RISC

- ARM, MIPS 등 (소프트웨어-managed TLB)
- TLB Miss 시 **hardware는 trap만 발생**
- 실제 페이지 테이블 lookup은 **OS 코드 (trap handler)**가 수행

**과정**

1. TLB Miss
2. 하드웨어가 **TLB_Miss Exception 발생**
3. OS Trap Handler 발생
4. OS가 Page Table Lookup 수행
5. TLB에 넣고 instruction을 재실행

> 장점 : 하드웨어가 간단
>
> 단점 : OS trap -> context swtich 성능 저하 



**코드 구현**

~~~c
VPN = Extract(VirtualAddress)

(Success, Entry) = TLB_Lookup(VPN)

if (Success == TRUE) {        // TLB Hit
    if (AccessAllowed(Entry.ProtectBits)) {
        offset = VA & OFFSET_MASK
        PA = (Entry.PFN << SHIFT) | offset
        AccessMemory(PA)
    } else {
        RaiseException(PROTECTION_FAULT)
    }
}
~~~

이 중에서 

~~~c
else {       // TLB Miss
    RaiseException(TLB_MISS)
}
~~~

- TLB Miss를 OS에 넘기는 것 = **ARM/RISC 스타일**

OS trap Handler에서 할 일:

1. Page Table에서 PTE 찾음.
2. 권한 체크
3. 유효하지 않으면 segfault
4. 유효하면 해당 VPN -> PFN 을 TLB에 넣음 
5. faulting instruction retry



## TLB Entry

- TLB는 **Fully Associative 방식**으로 관리된다.
  - 어떤 번역 (translation)도 TLB 의 어느 위치에나 저장될 수 있다.
  - 하드웨어가 모든 엔트리를 **병렬 탐색**하여 원하는 VPN을 찾는다. 

**구성 요소**

- **VPN (Virtual Page Number)** : 가상 페이지 번호
- **PFN (Page Frame Number)** : 실제 물리 프레임 번호
- **Other Bits** 
  - valid bit
  - protection bits
  - dirty bits
  - address-space identifier (ASID) 등



### Issue : Context Switching

- 프로세스가 전환할 때, 
  - TLB에 남아있는 이전 프로세스의 엔트리 때문에
  - **잘못된 PFN을 사용하여 메모리를 접근**할 위험이 있다. 

TLB는 **VPN만** 보고 찾기 때문에, 동일 VPN을 가진 다른 프로세스의 엔트리를 구분을 못한다. 

> TLB의 엔트리로만 **어떤 프로세스의 번역인지 판별이 불가능**



**해결 방법 : ASID** 

### ASID (Address Space Identifier)

- TLB 엔트리에 **ASID 필드를 추가하여** 같은 VPN이라도 프로세스별로 구분이 가능하게 한다. 
- 장점 : 
  - Context switching 시 TLB Flush 를 **완전히 할 필요가 없다.**
  - 같은 번호의 VPN이라도 프로세스마다 따로 관리된다. 



### Another Case 

**두 프로세스가 페이지를 공유하는 경우**

- 서로 다른 프로세스라도 **같은 물리 페이지(PFN)**을 공유할 수 있다.
- VPN이 다르지만 **PFN이 동일한 상황**
  - 페이지 공유는 **물리 메모리 사용량을 줄이는 장점이 있어서 사용**



#### LRU (Least Recently Used)

- TLB가 꽉 찼을 때 **가장 오랫동안 사용되지 않은 엔트리부터 교체**
- Locality (시간, 공간 지역성)를 활용하는 정책 

![LRU](/../images/2025-12-04-OS_7/LRU.png)



**실제 TLB 엔트리의 구성 (64-bit)**

| **필드**              | **역할**                                      |
| --------------------- | --------------------------------------------- |
| **19-bit VPN**        | 가상 페이지 번호                              |
| **24-bit PFN**        | 물리 페이지 번호 (64GB 주소공간 지원)         |
| **Global bit (G)**    | 여러 프로세스가 공유하는 페이지 표시          |
| **ASID**              | TLB 항목의 소유 프로세스를 구분               |
| **Coherence bit (C)** | 캐시 일관성(캐시 전략) 관련 설정              |
| **Dirty bit (D)**     | 페이지가 수정되었는지 여부(Write-back에 사용) |
| **Valid bit (V)**     | TLB 엔트리가 유효한지 여부                    |



> - 실제 시스템의 TLB는 매우 다양한 메타데이터를 포함
> - 이 비트들 덕분에 TLB는 **보안, 공유, 캐싱, 변경 여부**까지 모두 관리가 가능 





