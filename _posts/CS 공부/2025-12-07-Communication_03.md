---
layout: single
title: "컴퓨터 통신 03. 패킷 스위칭 (Packet Switching)"
categories: [Network]
tags: [컴퓨터 통신]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"

---

이번 포스트에서는 컴퓨터 통신의 **패킷 스위칭**에 대해 다룬다. 자세한 목차는 다음과 같다. 

1. 스위칭과 포워딩
2. 브리지(Bridge) 및 LAN 스위치
3. 셀 스위칭 (Cell Switching)



# 패킷 스위칭 (Packet Switching)

## 스위칭/포워딩 (Switching and Forwarding)

**확장성 있는 네트워크**

**1. 간접 연결 (Indirect connection)**

- 호스트들끼리 **바로 1:1로 케이블로 다 연결**하는게 아니라, 가운데에 **스위치/라우터 같은 중간 노드를 두고 거쳐 가는 구조**
  - 지리적으로 **넓은 영역**을 커버 가능
  - 호스트 수가 늘어나도, 기존 호스트 연결을 다 갈아엎지 않고 **중간 노드/링크만 조금씩 추가**하면서 확장이 가능하다. 

**2. 직접 연결과 비교**

- 직접 연결된 노드 사이 통신은 2계층을 이용
  - 바로 옆의 이웃과 말할때는 링크 계층 프레임만 주고 받으면 된다. 
- 멀리 있는 노드와 통신하기 위함.
  - 중간에 **3계층 (네트워크 계층, IP)**을 사용해서 여러 패킷 스위치 (라우터)를 거쳐서 전달 

**3. 3계층 추가 요소 : 패킷 스위치/라우터**

- 스위치 : **입력 포트**에서 패킷을 받아서 **패킷 헤더의 목적지 주소**를 보고 적절한 **출력 포트**로 내보낸다. 
  - 이 동작을 **store & forward**라고 부른다. 
  - 패킷을 먼저 수신하고 그 다음에 어디로 보낼지 결정해서 포워딩



**forward 방법**

- 내부 구조 
  - 왼쪽 : CPU + Main Memory + I/O bus
  - 오른쪽 : 여러 개의 Interface 1,2,3 (NIC 같은 역할)
  - 각 인터페이스는 실제 링크에 붙어 있다. 
- **Store&Forward** 흐름
  - 인터페이스에서 패킷을 받았을 때

1. 인터페이스가 패킷을 받아 **버퍼/메모리에 저장**
2. CPU가 그 패킷의 **헤더 (목적지 주소)**를 확인
3. **포워딩 테이블**을 보고 어느 인터페이스로 내보낼지 결정
4. I/O 버스를 통해 해당 인터페이스로 패킷을 넘겨 전송

- **CPU 중심 제어**
  - 간단한 구현에서는 **모든 포워딩 결정**을 CPU가 직접 수행 (유연하지만 느리다.)
  - 실제 고성능 라우터/스위치는 이 역할을
    - **전용 하드웨어 (ASIC, TCAM)** 가 일부 맡아서 속도를 높이지만 
    - 개념적으로는 CPU/제어부 + 여러 인터페이스 구조라고 보면 된다. 



### 데이터그램 (Datagrams)

데이터그램 모델의 특징

- **연결 설정 단계가 없다.**
  - 각 패킷이 독립적으로 바로 전송 된다. 
  - **비연결성 모델**이라고도 부른다. 
  - 주로 우편시스템에 비유 : 편지 하나하나가 각 패킷
- **각 스위치 역할**
  - **각각의 패킷을 독립적으로 포워딩**
    - 같은 흐름의 패킷이라도 **다른 경로**를 택할 수 있다. 
  - 각 스위치는 **포워딩 (라우팅) 테이블**을 유지 
    - 테이블 항목 : 목적지 주소 -> 출력 포트 번호
    - 이 테이블은 라우팅 알고리즘에 의해 채워진다. 



### 가상회선 스위칭 (Virtual Circuit Switching)

**가상회선 (Virtual Circuit) 이란**

- 패킷이 전달될 **경로를 미리 한 번 설정**하는 방식
- 이 후 전달되는 모든 패킷은 **같은 경로로 감**
  - **connection-oriented 방식 (연결지향형)**



**가상회선 VS 데이터그램**

1. 연결 설정 시간 

- VC 
  - 첫 패킷 보내기 전 왕복 지연시간 + a 동안 연결 설정을 해야한다. 
  - 스위치마다 VC table entry 생성이 필요함
- DG 
  - **연결 설정 X** 

> 데이터그램이 초기 지연이 훨씬 적다

2. 주소 오버헤드

- VC
  - 패킷은 **식별자 번호만 담으면 된다.**
- DG
  - 매 패킷마다 **목적지 전체 주소** 포함 (IP)

3. 패킷 포워딩 시간

- VC : 매우 빠름
- DG : 주소 기반 라우팅 테이블 검색으로 느릴 수 있음.

4. 장애 극복 

- VC : 경로 중 스위치/링크 고장나면 **다시 연결 설정이 필요**로 장애에 취약
- DG : 패킷은 독립적이기에 고장난 링크 우회 가능 

5. 자원 예약

- VC : QoS 제공 용이
- DG : QoS 제공 어려움 



**Virtual Circuit = Stateful**

- 연결 설정 중 **state 정보 생성**

**DataGram = Stateless**

- 패킷을 독립적으로 처리
- 스위치가 **연결 상태를 보존하지 않음**



**Soft State**

- stateless 처럼 **지속적 저장 X**
  - 일정시간 동안만 유지되는 상태 정보가 있음. 
- stateful 보다 유연하고, stateless보다 더 많은 기능 제공 가능 



### 소스 라우팅 (Source Routing)

- **발신자가 목적지까지의 경로를 직접 결정**하는 방식
- **패킷 헤더 안에 경로의 포트 번호 목록이 들어 있다.**
  - 각 스위치는 자신의 라우팅 테이블을 참고하는 것이 아니라 **패킷이 들고 있는 다음 포트 번호만 보고 포워딩**

장점 

- 스위치가 **라우팅 테이블을 유지할 필요가 없다.**
- 단순하다
- 경로 선택을 발신자가 직접 하기에 **특정 경로 지정이 가능하다.**

단점

- 발신자가 전체 네트워크 토폴로지를 알고 있어야 한다.
- 경로가 바뀌면 재전송 패킷 헤더도 수정해야 한다. 



### 스위치 성능

**1. 총 대역폭 (Aggregate Bandwidth)**

- I/O 버스가 지원 가능한 총 전송량
- **스위치 전체가 동시에 처리할 수 있는 용량**



**2. 초당 처리 가능한 패킷 수**

- 스위치는 패킷을 읽고 분석하고 포워딩하는 작업을 반복 
- 이 과정은 **I/O 인터럽트 + CPU 작업** 이기에 패킷 개수에 큰 영향 



---

## 브리지 및 LAN 스위치

### 브리지(Bridge)

- **LAN의 물리적 제한 + 트래픽 분리**

  - 전통 LAN은 하나의 세그먼트로 구성 
  - 물리적으로 너무 길거나, 호스트 수가 많으면 성능이 떨어진다. 

  > 세그먼트를 나누고 **브리지 (bridge)** 로 이어서 성능을 회복

- **Bridge로 여러 LAN을 연결** : **Extended LAN**

  - 두 개 이상의 LAN을 **리피터/브리지**로 연결할 수 있다. 
  - Repeater : 단순 신호 증폭 (1계층)
  - **Bridge** : **MAC 주소 기반으로 프레임을 보고 포워딩 (2계층)**



**브리지의 동작 원리**

- 주소를 보고 **selective forwarding**을 수행
- **Accept & Forward** 과정
  - 브리지는 들어온 프레임의 목적지 MAC 주소 확인 후
    - 같은 LAN 세그먼트에 있으면 : **필터링**
    - 다른 세그먼트에 있다 : **Forward**

- 2계층 연결 
  - 브리지는 **IP 헤더를 붙이지 않는다 (라우터와의 차이점)**
  - 프레임의 구조를 바꾸지 않는다. 



> **2계층 연결의 뜻**
>
> - 브리지는 L3 (IP 주소)를 가지지 않는다.
>   - 브리지는 네트워크 계층에게 **Invisible**하다
> - **헤더를 수정하지 않는다**
> - 확장 LAN은 논리적으로 하나의 LAN



### 학습 브리지 (Learning Bridge)

- 불필요할때는 포워딩을 하지 않는다.
  - **주소를 보고 판단** 하기에 같은 segment에 있으면 필터링이 가능하다. 
- **포워딩 테이블 유지 필요**
  - 브리지는 출발지 주소를 보고 테이블을 자동으로 학습함
  - 테이블 기반으로 목적지 포트가 정해진다. 
  - **스위치도 내부적으로 브리지와 동일하게 learning + filtering 구조**를 사용한다. 
- **Tree topology** 필요
  - loop 발생 시 전체 네트워크 마비 
- **Soft-state 테이블**
  - 엔트리마다 **TTL (Time to Live)** 존재



**포워딩 테이블 구성 원칙**

- 브리지의 1차 목적 : **연결**
  - 성능 개선은 2차의 목적
  - 따라서 조용히 동작 (호스트가 아무것도 몰라도 됨)
- 테이블은 완벽할 필요 없이 단순함. 
- **Over-engineering** 금지
  - 복잡한 일을 하려고 할 때 오히려 효율이 떨어진다. 



**과정**

1) 테이블이 비어 있는상황 : 목적지의 검색이 불가능 **Flooding**
   - 스위치가 MAC 목적지의 위치를 모르므로 모든 **포트로 브로드캐스팅**
   - 이 과정에서 출발지는 이미 업데이트 됨
2) 목적지 학습 이후에 **Selective Forwarding**
   - 스위치가 이제 경로를 알고 있음.
   - 따라서 다시 보내는 상황이 생기면 **바로 그 포트로만 Unicast로 전송**

3. **Soft-state TTL 적용**
   - 항목이 자동 갱신/삭제가 됨 
   - 이동 / 케이블 변경 등의 변화에 적응이 쉽다. 

> Flooding은 비용이 크지만 초기 학습을 위한 필수 단계



**브리지/LAN 스위치의 한계**

- 확장성이 없다. 
- 이질성 (heterogeneity) 허용하지 않는다. 
  - LAN switch/bridge는 동일한 2계층 기반에서만 작동
  - **네트워크 연결 불가능**
- **투명성** : 노드 입장에서는 브리지의 존재를 몰라야 한다.



---

## 셀 스위칭 (Cell Switching) : ATM

### ATM 

**ATM = 비동기 전송 모드 (Asynchronous Transfer Mode)**

- '비동기' 란, **고정된 타임 슬롯없이 필요할 때 전송**하는 방식 
- ATM은 패킷 스위칭 기반을 도입한 기술
  - 전화회사가 기존 회선 기반의 한계를 극복하기 위해 만든 **고성능 패킷 스위칭 기술**

- **극단적인 연결성 패킷 스위칭**
  - ATM은 패킷 스위칭이지만 **VC (가상회선)**을 설정해서 움직인다. 
- **고정 길이 패킷 = 셀(Cell)**
  - 크기 : 5-byte 헤더 / 48-byte 페이로드 
  - **따라서 작은 패킷으로 Overhead**가 증가 : 단 QoS 보장을 최우선

> 왜 고정길이인가?
>
> - **음성통신**에서의 지연을 최소화하기 위함 
> - 모으는 시간 (packetizing delay)이 너무 길면 통화 품질이 저하됨 





