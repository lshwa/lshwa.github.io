---
layout: single
title: "컴퓨터 통신 04. 인터네트워킹 (Internetworking)"
categories: [Network]
tags: [컴퓨터 통신]
typora-root-url: ../
toc: true
author_profile: false
sidebar:
  nav: "docs"


---

이번 포스트에서는 컴퓨터 통신의 **인터네트워킹**에 대해 다룬다. 자세한 목차는 다음과 같다. 

1. 인터네트워킹 기본 
2. 라우팅
3. 전역 인터넷 
4. Mobile Hosts



# 인터네트워킹 (Internetworking)

## 인터네트워킹 기본

### 인터넷 (Internet)

**인터네트워킹 (Internetworking)**

- 여러 개의 **서로 다른 네트워크를 연결**하여 하나의 커다란 네트워크처럼 동작시키는 것 
  - `네트워크들의 네트워크`

**인터넷 (Internet)**

- 인터넷은 **특수한 네트워크가 아니라** 다양한 네트워크들의 연속 (Concatenation)으로 이루어진 기본 구조 

- 네트워크 간의 경계가 불명확함 

  - 사용자, 공급자의 구분이 없이 단순히 네트워크가 연결
  - Ethernet, FDDI, Point-to-Point 등 서로 다른 기술의 네트워크들이 라우터를 통해 연결 

  > **네트워크들이 모두 동일할 필요가 없다. (이질성 허용)**



#### 인터넷 서비스 모델 

**번역 아닌 표준화**

- 서로 다른 네트워크 간에는 **번역 (Translation)**을 하면 오버헤드가 커지고 복잡함. 
- 인터넷은 **네트워크 계층 위에서 표준화 (IP 적용)**하는 방식을 사용:
  - 실제 데이터 전달은 각 네트워크 방식을 그대로 사용
  - 그 위에 공통으로 **IP를 올려서 통신**

**표준화 구조**

- 네트워크들은 링크 (L2)에서 자유롭게 동작
- 라우터 경계에서는 **IP (3계층)를 기준으로 통합**



### IP 구조 및 동작 원리

**전체 통신 경로 = 여러 네트워크 (LAN/WAN)의 조합**

- 각 구간마다 링크 계층이 다르다. 
- 가장 위에서 IP가 통합적으로 동작 

**핵심 원리 : IP는 "네트워크 위에 올라가는" 상위 계층**

- 링크 계층이 무엇이든, IP 헤더는 유지된 채로 각 링크 기술에 맞게 캡슐화/역캡슐화 진행

> 네트워크 내부에서는 IP 계층이 있는가? 
>
> : **반드시 없어야 한다.** 반드시 경계지점에서만 IP가 있어야 한다. 



**Repeater VS Bridege VS Router**

a) Router - 3계층 장치

- IP 기반 포워딩 수행 (L3 주소 기반)
- 서로 다른 네트워크 연결이 가능

b) Bridge - 2계층 스위치 (LAN 스위치)

- MAC 주소 기반으로 프레임 단위 포워딩 
- 이질적인 링크 연결이 힘들고, Broadcast 도메인 확장됨 

c) Repeater - 1계층

- 단순한 전기 신호 증폭으로 주소 개념이 없음 
- 거리 확장이 목적 



> IP의 internetworking 해법 정리

**라우터 지점에서 '네트워크 계층 위에서 표준화'**

- 라우터는 **네트워크들의 연결 지점**
- 라우터는 **네트워크 계층 (IP)**에서만 표준화해 처리
- 따라서 여러 기술 (이더넷, PPP, X.25, FDDI 등) 은 서로 완전히 달라도 무관 
  - 라우터는 아래 계층이 뭔지 몰라도, **IP 패킷만 이해하면** 포워딩이 가능하기 때문 
- **서로 다른 네트워크 사이에는 직접적인 관련성이 없다.**
  - 네트워크 계층에서 하나의 통일된 논리적 링크로 취급 

**중요 : 실제 네트워크 계층은, IP 네트워크에서는, 링크로 간주된다.**



### IP : 패킷 전달 서비스 모델

**IP 네트워크 구조**

- IP 노드 + 논리적 링크 (logical link)로 구성된 **데이터그램 기반 네트워크**
- 연결 설정 없음 **Connectionless**
- 전역 주소 체계 사용 
  - 인터넷 전체에 고유한 주소 필요 
  - `IPv4 = 32 bit`
  - 네트워크들 간 라우팅을 가능하게 하는 핵심 요소 
- **비연결성** : 전송 전에 회선 설정 X, 패킷 하나하나 독립적으로 처리
- **최선 노력 전달 (Best-effort delivery)** 
  - **서비스 수준을 낮추어 모든 네트워크에서 구현 가능하도록 하기 위함**
- **단편화 및 재조립** : IP 패킷 분할하는 경우



#### IP 패킷 헤더 형식

![IP 패킷 헤더](/../images/2025-12-10-Communication_04/스크린샷 2025-12-10 오후 8.05.28.png)

- Version (4bit) : 현재 IPv4 = 값 4
- Hlen (4bit) : 헤더의 길이를 32bit word 단위로 표현 
- Type of Service (TOS) : 원래 QoS 제공 목적, 현재는 잘 사용 X
- Total Length (16bit) : **IP 패킷 전체 길이 (헤더 + 데이터)의 byte 단위 길이**
- Identification / Flags / Fragment Offset 
  - **단편화 (fragmentation)** 를 위한 필드
  - 경로 중간에서 MTU 제한 때문에 패킷을 쪼갤 때 사용
- **TTL (Time to Live)** 
  - 패킷이 **최대로 방문할 수 있는 라우터 수**
  - 무한 루프 방지 
- Protocol : 상위 계층 프로토콜 구분 (MUX / DEMUX 키)
- Header Checksum : **IP 헤더만 검사**, 데이터는 포함 X
- **Source / Destination Address (각 32bit)**
  - 발신지/목적지 IP 주소
  - 전체 인터넷 전역 주소 



#### 단편화와 재조립 (Fragmentation & Reassembly)

**MTU (Maximum Transmission Unit)**

- 각 네트워크 기술은 **자신만의 최대 패킷 크기 (MTU)**를 가진다. 
  - Ethernet : 1500B / ATM : 53B
- **단편화가 필요한 이유** : `IP Datagram > MTU`인 패킷을 링크로 통과해야할 때
  - IP가 패킷을 여러 조각 (fragment)으로 나눈다. 

**IPv4 단편화 동작**

- **라우터에서도 단편화 가능**
- 분할된 조각들은 **Self-contatined Datagram** : 각각 독립적으로 전달됨
- **중간에서는 재조립 안 하고 무조건 목적지에서만 재조립 한다.**
  - 재조립 조건 : 모든 fragment가 도착해야 재조립이 가능 

**Ident 필드**

- 하나의 원본 Datagram이 여러 fragment로 나뉘어도 
  - Ident 값은 모두 동일
  - 목적지에 조립할 때 어떤 조각이 같은 Datagram인지 구분하는 역할 
- **Fragment Offset**
  - 패킷 내 데이터가 **원본 Datagram의 몇 번째 바이트부터인지** 나타냄
  - 단위 : 8-byte 단위



#### Global Address (전역 주소)

- **전역적으로 유일해야 한다.**
  - 인터넷은 전세계 네트워크의 연결이기에 IP는 **전 세계에서 유일해야 함**
- **계층적 구조 (Hierarchical)**
  - IP 주소 = `Network Part + Host Part`
  - 같은 네트워크에 속한 노드들은 **Network 부분이 동일**
- **Classful Addressing**
  - A Class (대규모 기관용) : `0 | Network(7bit) | Host(24bit)` 
  - B Class : `10 | Network(14bit) | Host(16bit)`
  - C Class : `0 | Network(21bit) | Host(8bit)`

- 점 표기법 : 4개의 8-bit을 10진수로 표기 ex) 192.168.1.20



### 데이터그램 포워딩 : IP의 실제 전달

- **IP는 네트워크계층 위의 프로토콜**
  - IP는 실제 네트워크들을 **하나의 가상 링크처럼 묶는 역할**을 함
  - 물리적으로 다른 네트워크들도 논리적으로 하나의 네트워크처럼 사용 가능
- **실제 전달은 네트워크 계층 아래의 '링크 계층'이 담당**
  - IP는 **논리적 (next hop)** 주소만 알고 있다. 
  - 실제로는 링크 계층이 Next hop의 MAC 주소를 이용해 전달 



**IP 패킷을 받은 라우터/호스트의 동작**

**Step 1 : 목적지 IP가 내 네트워크인가?**

- 같은 네트워크라면 **직접 포워딩 (ARP로 MAC 획득 후 전송)**
- 아니면? : **라우터의 포워딩 테이블을 참조해 next hop으로 전송**

**Step 2 : 포워딩 테이블 (라우팅 테이블) 조회**

- 포워딩 테이블에 있는 정보
  - **Network Number**
  - **Next hop 라우터 혹은 사용할 인터페이스 번호**

**Step 3 : 프레임 캡슐화 (encapsulation)**

- IP 헤더는 유지됨 (Source / Destination IP는 고정)
- 링크 계층 헤더는 매 홉마다 새로 붙는다.
  - **MAC 주소는 hop-by-hop 방식으로 계속 변경됨**



> 같은 네트워크 내부 

- 라우터를 거치지 않고, 스위치가 **MAC 기반으로 바로 전달**

> 다른 네트워크 

- IP 헤더는 end-to-end로 고정
- MAC 주소는 **hop-by-hop**으로 계속 재작성
- 라우터는 MAC 헤더를 제거하고 새로 붙인다. 



#### 주소 번역 (Address Translation)

- **인터넷은 논리적 (가상) 네트워크**
  - IP는 논리 주소이기에 실제 전송은 **물리적 네트워크 (Ethernet)의 MAC 주소를 사용**
- 데이터 전달 시 필요한 일 
  - IP 주소 -> 물리 주소 (MAC) 로 변환해야만 실제 네트워크에서 전송이 가능
- 변환이 필요한 주소 = **Next-hop의 물리 주소**
  - 목적지 호스트가 같은 LAN에 위치 = 목적지 MAC 주소 필요
  - 목적지가 다른 LAN = 다음 hop 라우터의 MAC 주소 필요 
- **필요한 MAC 주소 찾기 방법**

1. IP 주소 안에 **물리 주소 포함시키기**
   - IPv4는 주소 길이가 짧아서 불가능
   - IPv6는 128 bit라서 가능 
2. 테이블 기반 변환 (**ARP가 테이블을 만든다**)



#### ARP (Address Resolution Protocol)

ARP 의 역할 : **IP -> MAC 주소 변환을 위한 매핑 테이블 생성 프로토콜**

- 즉, **IP 주소가 주어지면 MAC 주소를 찾아주는 프로토콜**

**ARP의 동작방식**

1. ARP 테이블에 없으면 -> **Broadcast 요청**
   - 이 IP를 가졌으면 MAC 주소 알려달라고 요청
2. 해당 IP를 가진 호스트가 **자신의 MAC 주소를 Unicast로 응답**
3. 응답 받은 내용은 **ARP 테이블에 캐싱 (soft state)**
   - 일정 시간 안 쓰면 삭제됨 (TTL 기반)

> ARP는 링크 계층 (Ethernet)에서 동작, IP 계층이 사용



#### DHCP : 호스트 구성

**1. IP 주소 배정은 네트워크 구조를 반영해야 한다.**

- 같은 LAN 에 있는 장비들은 IP 앞부분 (네트워크 부분)이 같아야 한다. 
- IP 주소 배정은 수동으로 하면 복잡하고 실수도 많다. 

**2. IP 외에도 설정해야 할 것들**

- Default gateway : 라우터 주소 
- DNS 서버 주소
- Subnet mask

**3. DHCP 등장 이유 : 이 많은 설정을 자동으로 해주는 프로토콜**

> DHCP = Dynamic Host Configuration Protocol



**DHCP 서버는 반드시 라우터에 있어야 하는가?**

**아니다** : 다른 네트워크 어딘가에도 있어도 상관이 없다. 

- **DHCP Relay**가 중간에서 전달해주기 때문

**DHCP의 동작 순서**

- D : Discover (BroadCast) -> O : Offer (Server -> Client) -> R : Request -> A : ACK 

**DHCP Relay의 동작**

- 호스트가 broadcast로 DHCP discover 전송
- relay (라우터)가 그것을 받아 **DHCP 서버로 unicast 전달**
- 서버는 reply -> relay -> host 로 돌아온다. 

> **공유기에서 DHCP 작동 이유**
>
> - 공유기 내부에 DHCP 서버가 내장되어 있다. 



#### ICMP (Internet Control Message Protocol)

> ICMP = **IP 동작 보조 제어 프로토콜**

- **ICMP는 제어 (Control) 메시지를 전달하는 프로토콜**
  - IP는 **최선 노력 전송 (Best Effort)** : 오류 발생 시 왜 실패했는지 말해줄 능력이 없다. 
  - 따라서 **오류 보고/진단/경로 문제 알림**을 담당하는 보조 프로토콜이 필요
- **IP 패킷에 포함되지 않고 별도의 protocol**
- **ICMP는 IP의 'Companion Protocol'**
  - 필수는 아니지만 매우 중요
  - 데이터 흐름과 분리된 제어 흐름 **control plane**

**제어 작업 내용**

**1) 진단 (Diagnostic)**

- 대표 기능 : **Echo Request / Echo Reply**
  - ping 명령어 바로 이 기능 사용
  - 목적지까지 왕복이 되는지, 네트워크 연결 상태를 확인

**2) 오류 보고 (Error Reporting)**

아래와 같은 경우에 라우터/호스트가 ICMP 메시지 생성

- 도착 불가 : 프로토콜/포트/호스트가 존재하지 않음. 
- TTL 초과 : 라우팅 루프 혹은 지나치게 김 
- CheckSum 실패 : 데이터그램 손상됨
- Fragmentation 필요하지만 DF 비트가 1 : MTU 보다 큰 패킷 발생
- Redirect (라우터 변경) : 호스트가 잘못된 라우터로 보낼 때 알려줌



**누가 보내는가?**

- 호스트 or 라우터가 보낸다. 
  - 해당 위치에서 **ICMP 생성해서 원래 송신자에게 보낸다.**

**언제 생성되는가?**

- 문제 발생 순간 + 원래 패킷 처리가 안될 때 

**어디서 패킷 구조가 결정되는가?**

- ICMP 메시지도 결국 **IP 헤더 + ICMP 헤더 + ICMP 데이터** 로 구성

예시

~~~bash
IP(src=A, dst=B)
  ICMP(type=8, Echo Request)
~~~

TTL exceeded 

~~~bash
IP(src=R1, dst=A)
  ICMP(type=11, Time Exceeded)
    (원래 IP 헤더 + 8byte payload 일부 포함됨)
~~~

- 송신자가 어떤 패킷이 문제였는지를 알아야 하기 때문에 원래 패킷 head 일부를 포함시킴



---

## 라우팅

**라우팅이란?**

- 라우터가 '어디로 보낼지' 결정하는 과정
  - IP 패킷을 다음 목적지로 보내기 위해 **라우팅 테이블 (Routing Table)**을 확인하고 해당하는 **다음 홉 (next hop)**을 선택하는 것이 라우팅

- Network 주소 기반으로 다음 방향을 결정하는 것 

**라우팅 테이블 정보**

- 라우터는 목적지 IP 주소를 보고 그 IP가 속한 **네트워크 번호**를 찾고, 그 네트워크에 대해 **다음으로 패킷을 넘겨야 할 포트/라우터**를 결정함 



> **포워딩 = 실행** / **라우팅 = 설계**



---

## 전역 인터넷 (Global Internet)

**개요 : (비례) 확장성 문제 (Scalability Issues)**

- **Flat Address vs Hierarchical Address**
  - Flat 주소 : 구조가 없이 숫자만 존재하는 형태 (규모가 커질수록 너무 커짐)
  - Hierarchical 주소 : IP 주소는 계층 구조를 가짐. (이론적 확장성 좋음)
- **Classful 주소 체계는** 비효율이 굉장히 크다. 
- 현실의 인터넷은 **수만개의 네트워크로 구성** : 네트워크의 수가 많다. 



### 서브넷팅 (Subneting)

**서브넷팅** : 네트워크를 내부적으로 **여러 개의 작은 네트워크 (subnet)**로 나누는 기술

- 주소 계층에 **또 다른 단계**를 추가하는 개념
- 기존 네트워크 주소를 더 쪼개서 사용

**Subnet Mask**

- **Host의 일부를 'Subent ID'로 뺏아간다**
  - 기존 Class B 주소 : Network (16bit) + Host (16 bit)
  - Subnetting : Network (16bit) + **Subnet (8bit)** + Host (8bit)
- **서브넷은 외부에서 보이지 않는다.**
  - **사이트 내부에서만 의미가 존재한다.**
  - 외부 라우터 입장에서는 하나의 네트워크로 보인다. 

**라우터의 패킷 전달 알고리즘**

~~~python
for each entry (SubnetNum, Mask, NextHop):
    D1 = DestinationAddress & Mask
    if D1 == SubnetNum:
        if NextHop is interface:
            deliver directly to D
        else:
            deliver to NextHop router
~~~

- **AND 연산**으로 목적지 Subnet 판별
- **직접 연결된 Subnet 이면 ARP로 MAC을 얻어 바로 전달**
  - 아니라면 Nexthop으로 라우터로 전달 

> **하나의 물리적 네트워크에 여러 개의(논리적) 서브넷이 존재할 수 있다.**



**Subnet 사용 전과 이후**

- 사용 전 : Classful 방식 -> 목적지 주소를 보고 Class A/B/C 확인
- 사용 후 : **Network ID = 목적지 주소 & Subnet Mask**

**Subnet의 의미**

- 조직 내부에서 네트워크를 자유롭게 분리해서 관리가 가능
- 고정된 class의 제약이 없이 유연하게 network 공간설계가 가능
- 외부에서는 subnet이 보이지 않기에 외부 라우터는 단 하나의 엔트리만 유지하면 된다. 



### CIDR (Classless Inter-Domain Routing)

**개념 : class 구분 없이 필요한 만큼만 주소를 할당**한다. 

- **연속된 네트워크 번호를 block 단위로 묶음 (Aggregation)**
- 각 묶음 (block) 표현 : `(first_network_address, count)`

**표기법** : **prefix length(/x)**를 사용

- Prefix 길이 = 네트워크 주소의 bit 수 
- 비트마스크 (CIDR mask)를 통해 block 크기 표현 

**CIDR Aggregation** : 여러 개의 인접 네트워크가 존재할 때 상위 라우터는 이를 **하나의 큰 prefix**로 표현해 테이블을 축소한다. 



> Subnet Vs Classless (CIDR)

| **문제**          | **Subnet(서브넷)**       | **Classless(CIDR)**       |
| ----------------- | ------------------------ | ------------------------- |
| 주소 공간 부족    | 일부 해결(사이트 내부만) | 완전 해결(인터넷 전체)    |
| 라우터 Table 크기 | 줄여주지 못함            | Aggregation으로 크게 감소 |
| 적용 범위         | 내부 네트워크            | 전 세계 인터넷            |



### 공유기

**개념 : 하나의 공인 IP 주소를 여러 내부 호스트가 함께 사용하는 장치**

- ISP (인터넷 제공업체)는 가정에 **공인 IP 하나**를 할당해준다. 
- 집 안에서 공유기가 내부 네트워크를 만들어 여러 장치가 인터넷을 쓰게 함 

> 이 구조를 가능하게 하는 기술이 **NAT**



**공유기의 상세 기능**

- **IP 라우터** : 내부에서 외부 인터넷으로 패킷을 전달 
- **DHCP 서버** : 내부 장치들에게 **사설 IP** 자동 배정
- **LAN Switch 기능** : 유선 LAN들 간 L2 스위칭 수행
- **AP (Access Point)** : 무선 통신 제공
- **NAT (Network Address Translation)** : 하나의 공인 IP를 여러 내부 장치가 공유할 수 있게 하는 핵심 기능
- **Firewall** : 기본적으로 외부에서 내부로의 접근 차단 



#### NAT : network address translation

![NAT 동작 원리](/../images/2025-12-10-Communication_04/스크린샷 2025-12-11 오후 2.25.10.png)

**NAT의 핵심 개념 흐름**

**1. 내부 호스트가 외부로 패킷을 전송**

- 출발 : `10.0.0.1: 3345`
- 목적지 : `128.119.40.186 : 80`

**2. NAT 라우터가 주소 변환**

- 소스 주소가 변경 : `(10.0.0.1, 3345) -> (138.76.29.7, 5001)`
- 그 후 NAT 테이블에 다음이 저장

| **WAN 주소**       | **LAN 주소**    |
| ------------------ | --------------- |
| 138.76.29.7 : 5001 | 10.0.0.1 : 3345 |

**3. 웹 서버의 답장이 NAT으로 돌아옴**

- 목적지 : `1138.76.29.7 : 5001`

**4. NAT는 다시 역변환하여 내부 호스트로 전달**

- `(138.76.29.7 : 5001) -> (10.0.0.1 : 3345)`



**용도별 공유기 설정** : 공유기를 2가지 모드로 사용할 수 있다.

**1) 라우터 모드** (일반 모드)

- 독립된 IP 네트워크 생성
- 내부 사설 IP 부여
- NAT을 사용하여 외부를 통신
- 집에서 기본적으로 사용하는 방식



**2) AP / Switch / Repeater 모드**

- NAT, DHCP 기능 OFF
- 기존 네트워크를 확장하는 역할만 수행
- 하나의 IP 네트워크로 동작



**인터넷에서 사설  LAN 안으로 접근**

- 보안 위험 인지는 필수
  - 내부 사설망은 외부에서 기본적으로 접근 불가 : 보안상 매우 중요
  - 하지만 내부 PC에 외부접속을 허용하기 위해 **추가 보안 설정이 반드시 필요**
- **외부 연결 서버에 등록**
  - 집/학교 같은 환경에서 **공유기 주소는 ISP가 DHCP로 주기 때문에 바뀜 (동적 IP)**
  - 해결하기 위한 방법
    - **Static IP 구매**
    - **Dynamic DNS (DDNS)** : 동적 IP를 자동으로 도메인과 맵핑

- **Nat Table static entry 설정**
  - **Port Forwarding** : 특정 포트로 들어오는 외부 트래픽을 내부 특정 PC 로 전달
  - **DMZ** : 모든 포트를 특정 내부 PC로 포워딩 (사실상 외부에 완전 공개한 것이기에 매우 위험)

- 기타 보안 설정 : 방화벽 포트, 내부 IP, 불필요한 원격 접속 서비스 off



### Virtual Networks

**실제 물리 연결과 독립적으로 구성되는 네트워크**

- 물리적 연결은 같더라도 **논리적으로 다른 네트워크처럼 동작**하도록 만들 수 있다. 
- 대표적 예시 : VPN (Virtual Private Network)
  - **전용선 대신 인터넷을 이용해 사설망을 구성**
  - 회사 지사와 본사 연결 등이 인터넷 위에서 구현
  - 장점 : 비용 절약 (전용선 대신 인터넷 사용), 보안 기능 제공 (IPSec)
- **IP 망은 기본적으로 모든 노드가 서로 통신 가능**
  - 사설망처럼 보이기 위해서는 **IP 터널링 (Tunneling)** 기술이 필요 
  - 데이터에 새로운 IP 헤더를 씌어서 목적지까지 전달 가능



#### IP 터널링 (Tunneling)

**개념 : IP 패킷을 다른 IP 패킷 안에 넣어서 전달** : Encapsulation

- A 네트워크 -> 인터넷 -> B 네트워크 
- 하지만 A와 B 사이를 '같은 네트워크'처럼 보이게 하는 기술
- Why 필요할까?
  - 원래 외부에서는 사설망 주소를 모른다. 
  - 그러나 두 회사/자사끼리 논리적으로 연결하기 위해 필요하다.
  - **VPN 구현의 핵심 원리**

**구조 설명**

1. 호스트 A가 목적지의 사설망 주소로 패킷을 전송

~~~bash
IP header: Destination = 2.x (사설망 내부 목적지)
~~~

2. Router R1이 이 패킷을 받아 **터널 시작점 (Entry)**
   - 패킷을 다시 새 IP 헤더로 감싸서 캡슐화 

~~~bash
outer IP header: Destination = R2 (터널 끝점)
inner IP header: Destination = 2.x (실제 목적지)
~~~

3. 인터넷을 통해 R2까지 전달됨 
   - 여기까지 외부망은 내부 목적지를 모른다. 
4. Router R2가 Decapsulation : 내부 네트워크로 전달 



**IP 터널링의 의미**

1. **Indirecton**의 도입 : 중간 목적지를 **새로운 IP 헤어데 넣어서** 전달 
2. 유연성과 가상화 제공
3. 전 세계 인터넷 위에 개인 네트워크 구축이 가능

> **미래 통신망 핵심 기술**



**터널링/가상네트워크 사용 이유**

**1) 보안 (VPN의 대표 목적)**

- 공용 네트워크 위에 **사설 링크(논리적 링크)**를 얹는 방식 : 외부에서 내부망처럼 접근이 가능
- 암호화도 함께 사용하여 데이터 도청, 변조를 방지
- 회사 밖에서 회사 내부망 접속할 때 필수



**2) 특수 기능 구현**

- 물리 네트워크가 지원하지 않는 기능을 **가상 네트워크로 구현**
- 멀티캐스트 라우팅 기능
- 여러 특수 목적 라우팅 기능을 가진 가상 네트워크 구축
  - 네트워크 기능 확장이 어려울 때 가상 네트워크로 기능을 실험하거나 제공



**3) 비 IP 패킷 전달 (IP망을 통한 비-IP 패킷 전달)**

- IPv6 패킷을 IPv4 네트워크 위에 전달해야하는 상황



> VPN 서비스
>
> - **VPN은 '사용자에게 제공되는 서비스' 형태**
>   - 단순한 기술이 아니라 서비스 상품화됨
>   - TCP 터널링 등 IP 상위 계층에서도 구현
> - **실제 목적 : 차단 우회**
>   - 특정 국가/기관이 **목적지 IP 또는 출발지 IP**기준으로 차단하는 경우 존재
>   - VPN은 차단되지 않은 나라의 서버로 먼저 접속하여 그 서버에서 다시 목적지로 트래픽을 전달하여 **결과적으로 차단한 필터링을 우회**
> - VPN 내부 동작 = **Proxy + Tunnel**



### 차세대 IP : IPv6

IPv4 주소 고갈 + 보안/성능/서비스 품질 요구 증가로 인해 등장한 차세대 프로토콜

**주요 기능**

- **128-bit 주소** : 주소 공간이 사실상 무한 : 주소 부족 문제 해결
- **멀티캐스트 강화** : 그룹 통신 최적화, 브로드 캐스트 제거
- **실시간 서비스 (Qos)** : 실시간 트래픽 (음성/영상) 우선 처리 가능
- **인증 및 기밀** : IPv6는 보안 기능을 표준 탑재
- **자동 구성 (AutoConfiguration)** : DHCP 없어도 스스로 주소 생성 가능
- **종단간 단편화** : **호스트만 단편화 가능** : 라우터 부담이 줄어든다.
- **프로토콜 확장 용이** :확장 헤더로 새로운 기능 추가하기에 쉬움



**주소 형식 / 할당 구조**

`x:x:x:x:x:x:x:x (각 x = 16비트, Hex)`

- 연속된 0 -> :: 로 1번만 축약 가능
  - 즉 IPv4 주소와도 호환이 가능하다. 

- Subnet ID, Classless 개념을 모두 도입했다. 



**IPv6 헤더 구조**

| **필드**                         | **설명**                                       |
| -------------------------------- | ---------------------------------------------- |
| **Version**                      | IPv6 = 6                                       |
| **Traffic Class**                | IPv4 TOS와 동일, QoS에 사용                    |
| **Flow Label**                   | 실시간 스트림 식별                             |
| **Payload Length**               | 데이터 길이                                    |
| **Next Header**                  | 다음 확장 헤더 or 상위 프로토콜(TCP=6, UDP=17) |
| **Hop Limit**                    | TTL에 해당                                     |
| **Source / Destination Address** | 128bit 주소                                    |

- 옵션 영역이 사라지고 **확장 헤더로 독립적**



**IPv6 Next Header (확장 헤더 체인 구조)**

- 다음 확장 헤더 타입을 명시 
- 마지막 확장 헤더의 Next Header가 **TCP/UDP 번호**가 된다. (상위 프로토콜 전달)



---

## Mobile IP

**이동 호스트에 대한 패킷 전달**

- **문제 : IP 주소는 '계층적 주소'**
  - 따라서 호스트가 **다른 네트워크로 이동하면, 네트워크 주소 부분이 달라진다.**
  - 기존 주소로는 패킷 전달이 불가능함. 
- **이동 시 발생 문제**
  - IP 주소가 네트워크에 맞게 변해야하는데, 주소가 바뀌는 순간 **기존 연결 (TCP session)**이 끊어진다. : 서비스 끊김
  - 새 IP 주소를 할당하는 방식은 X

**Mobile IP 접근**

**목표 : 호스트의 이동이 Network 관점에서 투명해야 한다.**

- 이미 동작 중인 통신 소프트웨어, 라우터를 변경하지 않고 동작해야 한다. 

해결해야 할 부분 : 호스트의 **original Home IP** 주소는 유지, 이동 시 **현재 위치를 나타내는 임시 주소** 사용, 패킷을 **우회**하여 이동된 위치로 전달 



### Celluar Networks

(Mobile IP와 굉장히 유사한 구조)

**구성 요소** 

- HLR (Home Location Register) : 이 사용자의 기본 위치 정보
- VLR (Visiited Location Register) : 사용자가 방문한 지역에서 임시 등록되는 위치 정보
- MSC (Mobile Swithcing Center) : 전화 통신을 라우팅하는 스위치 센터

**동작 방식**

1. 전화 건 사람의 신호가 호출자의 home MSC로 감
2. MSC는 HLR에서 사용자가 어디에 있는지 위치를 조회
3. HLR은 roaming 번호 (현재 위치 MSC 번호) 전달
4. Home MSC는 그 roaming 번호로 전화 연결 생성
5. Visited MSC가 기지국을 통해 단말기로 최종 연결 



### Mobile IP

**구성 요소**

**1) Home Address** : 호스트가 원래 속한 네트워크의 **영구적 주소**

**2) Home Agent** : 홈 네트워크에 있는 라우터 역할, 이동 호스트에게 전달될 패킷을 가로채서 포워딩하는 역할 

**3) Foreign Agent** : 이동한 방문 네트워크의 라우터

- 모바일 호스트에게 **임시 주소를 부여하거나 전달**

**4) CoA (care-of-address)** : 이동 호스트의 **현재 위치를 나타내는 주소**

- 패킷이 여기까지 전달되면 FA가 모바일에게 전달 



**동작 원리**

1. HA&FA는 주기적으로 자신의 존재를 홍보
2. 이동 호스트가 외부 네트워크에 들어오면 FA를 감지
3. FA가 HA에게 '이 호스트는 현재 여기 있음 (CoA)' 알려줌
4. HA는 모든 패킷을 CoA로 캡슐화하여 전달 
5. FA가 다시 실제 호스트로 전달 



### Mobile IP의 패킷 전달 (수신 측)

핵심 : **이동했다는 사실을 외부가 모르게 Indirection** 하면서 패킷을 이동 호스트까지 전달하는 구조 

**1. 송신자가 Home Agent (HA) 로 전송**

- 송신자는 이동했는지를 모름.
- 기존 **Home Address (영구 주소)**로 패킷을 보낸다. 
  - IP 주소는 네트워크 주소를 포함하기에 이동 사실이 반영되지 않는다. 



**2. Home Agent가 가로채기 (Proxy ARP 사용)**

- HA가 '여기 Home Host 대신 받아줄게' 하고 **대리 응답**
- 자기가 대신 패킷을 수신한다. 



**3. HA -> Foreign Agent (FA) 로 터널링**

- HA는 FA의 **care-of-address (CoA)**를 알고 있다. 
- 패킷을 **IP-in-IP encapsulation**을 해서 FA에게 전달



**4. FA -> 이동 호스트 전달**

- 이때는 **Link-Layer 전달 (MAC 기반 전달)**
- IP Forwarding이 아니고, 같은 네트워크 내 전달처럼 처리 



#### 경로 최적화

**Triangle Routing 문제** 

- 불필요하게 **HA를 우회하는 비효율**
- 네트워크 지연 증가 + 비용 증가



**해결 : Route Optimization**

1. HA가 송신자에게 **blinding update 메시지** 전달
   - 이동 호스트는 지금 CoA에 있다고 알려준다.
2. 송신자는 blinding cache에 다음 정보를 저장
3. 이후 패킷은 HA를 거치지 않고 바로 FA로 터널링 











